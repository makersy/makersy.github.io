<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer-正则表达式匹配]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数用来匹配包括&#39;.&#39;和 &#39;*&#39; 的正则表达式。模式中的字符&#39;.&#39;表示任意一个字符，而 &#39;*&#39; 表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。 题解 markdown里面的 * 需要转义，一个个转实在有点麻烦，还是把文字放在代码块里好了。 1234567891011121314151617我们可以把问题转换为当前字符的下一个字符是否为 * 来处理，那么就归纳为以下几种情况：1. 如果字符串当前位置的下一个字符不是*，那么： # 字符串与模式的当前位置字符匹配：字符串和模式的索引均向后移一位，继续匹配之后的； # 字符串与模式的当前位置字符不匹配：返回false。 2. 如果字符串当前位置下一个字符是*，那么： # 如果当前位置字符不匹配：模式索引后移2位，字符串不变，相当于 x* 这两个字符被忽略掉， 因为 * 可以匹配0次； # 如果当前位置字符匹配，有三种方式继续匹配，采取递归来一一试探： ## 模式索引后移2位，字符串不变，相当于 x* 这两个字符被忽略掉； 这里解释下为什么这么做。 举个栗子，"bbbba"和".*a"，如果到了第4个b的时候没有把".*"给跳过去，那么 ".*"还会继续匹配下个字符a，那么模式中的a就得不到匹配，返回false。实际上 如果".*"匹配了4个b，然后再匹配最后那个a，是true的； ## 字符串索引后移1位，模式不变，即使用当前字符继续匹配字符串，因为 * 可以匹配多次； ## 字符串索引后移1位，模式后移2位，即 x* 只匹配1次。 代码如下： 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if( str==null || pattern==null ) return false; return matchSub(str, 0, pattern, 0); &#125; public boolean matchSub(char[] str, int strIdx, char[] p, int pIdx)&#123; //如果匹配完成，返回true if( strIdx==str.length &amp;&amp; pIdx==p.length ) return true; //如果pattern先到最后，返回false，这样的话匹配是必定失败的 if( strIdx != str.length &amp;&amp; pIdx==p.length ) return false; //第二个是* if( pIdx+1 &lt; p.length &amp;&amp; p[pIdx+1]=='*' )&#123; //字符串没到尾，且当前位置匹配，三种情况 if( strIdx!=str.length &amp;&amp; str[strIdx]==p[pIdx] || strIdx != str.length &amp;&amp; p[pIdx]=='.' )&#123; return matchSub(str, strIdx, p, pIdx+2) || matchSub(str, strIdx+1, p, pIdx) || matchSub(str, strIdx+1, p, pIdx+2); &#125;else &#123; //字符串到尾，或者当前位置不匹配，都把模式向后移动2位，因为*是可以匹配0次的 return matchSub(str, strIdx, p, pIdx+2); &#125; &#125; //第二个不是*，且当前位置匹配 if( strIdx != str.length &amp;&amp; (str[strIdx] == p[pIdx] || p[pIdx]=='.') )&#123; return matchSub(str, strIdx+1, p, pIdx+1); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的注解]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2FJava%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[介绍注解（Annotation ），有标记、注释的意思，也被称为元数据，他为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。在 Java 中注解是一个很重要的知识点。 Java 注解是从 Java SE5 引入的。他可以提供用来完整描述程序所需的信息，为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。 标准注解注解的语法比较简单，除了@符号的使用之外，基本与Java固有语法无异。JDK5内置了三种，定义在java.lang中的注解： @Override，表示当前方法定义将覆盖超类中方法。如果将这个单词拼写错误，或者方法签名对应不上被覆盖的方法，那么编译器就会发出错误提示。 @Deprecated，如果使用了注解为这个单词的元素，那么编译器就会发出警告。 @SuppressWarnings，关闭不当的编译器警告信息。 元注解元注解专职负责注解其他注解，Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。 @Target：用于描述该注解的适用范围： 12345678取值(ElementType)有： 1.CONSTRUCTOR:用于描述构造器 2.FIELD:用于描述域（包括enum实例） 3.LOCAL_VARIABLE:用于描述局部变量 4.METHOD:用于描述方法 5.PACKAGE:用于描述包 6.PARAMETER:用于描述参数 7.TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention：表示需要在什么级别保存该注解信息 (生命周期) 某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。 1234取值（RetentionPoicy）有： 1.SOURCE:在源文件中有效（即源文件保留），会被编译器丢弃 2.CLASS:在class文件中有效（即class保留），但会被VM丢弃 3.RUNTIME:在运行时有效（即运行时保留），可以通过反射机制读 取注解的信息 @Documented：包含在Javadoc中 描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化 @Inherited：允许子类继承父类中的注解 如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。 当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 自定义注解12定义注解格式： public @interface 注解名 &#123;定义体&#125; 关于Annotation类型里面的参数该怎么设定:第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型； 第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String。 注解的使用刚接触注解时，我想很多人都会有一个疑问，这个东西有什么用呢？官方文档给了我们答案： 注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。 注解有许多用处，主要如下： 提供信息给编译器： 编译器可以利用注解来探测错误和警告信息 编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。 运行时的处理： 某些注解可以在程序运行的时候接受代码的提取值得注意的是，注解不是代码本身的一部分。 在Spring中大量使用了注解，比如常用的@Controller、@Service等，这些注解大大简化了方法的配置工作。 在此我用上述作用的第一个：提供信息给编译器，来做一个示范。 假设我在一个类里面定义了很多方法，我需要检查每一个方法是否有异常，并将其一一打印，那么我就可以在需要检查的方法上加一个注解，然后用反射的方法来调用方法并获取其注解，判断并打印之。 首先是注解类： 123456789/** * Created by makersy on 2019 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface CheckException &#123; public String description() default "no description";&#125; 然后是方法类： 12345678910111213141516171819202122232425262728293031323334353637/** * Created by makersy on 2019 */public class SomeMethods &#123; @CheckException(description = "减法") public static void method1() &#123; System.out.println("1 - 1 = " + (1 - 1)); &#125; @CheckException(description = "加法") public static void method3() &#123; System.out.println("4 + 3 = " + (4 + 3)); &#125; @CheckException(description = "乘法") public static void method2() &#123; System.out.println("2 * 3 = " + (2 * 3)); &#125; @CheckException(description = "除法") public static void method4() &#123; System.out.println("5 / 0 = " + (5 / 0)); &#125;// @CheckException// public static void method5() &#123;// System.out.println("1 - 1 = " + (1 - 1));// &#125; //没有注解的类，在主方法中不会被调用到 public static void method6() &#123; System.out.println("no annotation"); &#125; &#125; 最后是测试类： 1234567891011121314151617181920212223242526/** * Created by makersy on 2019 */public class TestTool &#123; public static void main(String[] args) &#123; SomeMethods someMethods = new SomeMethods(); int cnt = 0; //异常计数 for (Method method : SomeMethods.class.getDeclaredMethods()) &#123; if (method.isAnnotationPresent(CheckException.class)) &#123; //判断注解是否为我们定义的那个 CheckException anno = method.getAnnotation(CheckException.class); //获取CheckException注解 System.out.println(anno.description() + ":"); //打印方法注解的描述 try &#123; method.invoke(someMethods, null); //调用方法 &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; System.out.println(method.getName() + " has error. Caused By: " + e.getCause().getClass().getSimpleName()); System.out.println(e.getCause().getMessage()); cnt++; //异常计数+1 &#125; &#125; &#125; System.out.println(someMethods.getClass().getSimpleName() + " has " + cnt + " error!"); &#125;&#125; 下面是结果展示：]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP流量控制与拥塞控制原理分析]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2FTCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[TCP的流量控制使用滑动窗口进行流量控制所谓的流量控制，就是让发送方的发送速率不要太快，让接收方来得及接收。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。 如图说明了如何利用滑动窗口机制进行流量控制。 设主机A向主机B发送数据。假设B发送给A的rwnd (receiver window，窗口值) 是400，发送方的发送窗口不能超过接收方给出的接收窗口的数值。TCP的窗口单位是字节，不是报文段，请注意。 再设每一个报文段为100字节长，序号的初始值为seq=1。注意图中的大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值。 接收方的主机B进行了三次流量控制。第一次把窗口设置为rwnd=300，第二次减小到rwnd=100，最后减到rwnd=0，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。另外B向A发送的三个报文段都设置ACK=1，可以看出只有在ACK=1时确认号字段才有意义。 假如，B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd=400的报文段，然而这个报文段在传送中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。这样就死锁了。 为了解决这种死锁状态，TCP为每个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方重设持续计时器；如果窗口不是零，那么死锁就不会发生了。 注意：即使是零窗口，也必须接收这几个报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段。因此上述的零窗口探测报文段也是可以被接收到的。 TCP报文段发送时机的控制控制TCP报文的发送时机主要有以下几种机制。1）TCP维持一个变量，它等于最大报文段长度MSS，只要缓存中存放的数据达到MSS字节就组装成一个TCP报文段发送出去。2）由发送方的应用程序指明要求发送报文段，即TCP支持的推送(push)操作3）发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（长度不超过MSS）发送出去。 Nagle算法在TCP实现中广泛使用Nagle算法。算法是这样的：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，也就是说数据从进程到发送缓存是挤牙膏似的一点点的发送，那么就先把第一个字节发出去，等发送方收到对第一个数据字符的确认后，把数据积攒成一个大的数据块（报文段）发送出去，继续对随后到达的数据进行缓存。发送方每次只有收到接受方对前一个报文段的确认后才发送下一个报文段。 当数据到达较快而网络速率较慢时，用这样的方式可以明显的减少所用的网络带宽。 该算法还规定，当到达的数据已达到发送窗口大小的一般或已达到报文段的最大长度时，就立即发送一个报文段，这样做可以有效地提高网络的吞吐量。（吞吐量：单位时间从网络从网络输出的分组数目） 总体来说，目的是使得在发送方不发送很小的报文段的同时，接受方也不要在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息发送给对方。 TCP的拥塞控制拥塞控制的原理拥塞控制的产生在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变差，这种情况叫做拥塞。也就是说：$$\sum对资源的需求 &gt; 可用资源$$ 网络拥塞往往是由许多因素引起的，简单的提高节点处理机的运算速度，或者扩大结点缓存的存储空间，在很多时候并不能解决拥塞问题。例如1）当某个结点缓存容量扩展到非常大，于是凡到达该结点的分组均可在结点的缓存队列中排队，不受任何限制。由于输出链路的容量和处理机的速度并未提高，因此在这队列中的绝大多数的分组在排队等待时间会大大增加，结果上层软件只好把他们进行重传（因为已超时）。 因此，问题的实质往往是整个系统的各个部分不匹配，只有各个部分平衡了，问题才会得到解决。 拥塞控制和流量控制的不同所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。它是一个全局性的过程，涉及到所有的主机、所有的服务器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。 拥塞控制设计拥塞控制是很难设计的，因为它是一个动态的问题，许多情况下，甚至正是拥塞控制机制本身成为引起网络性能恶化甚至死锁的原因。从控制理论的角度来看拥塞控制这个问题，可以分为开环控制和闭环控制两种方法。开环控制就是在设计网络时事先将有关拥塞发生的所有因素考虑周到，一旦系统运行起来就不能在中途改正。闭环控制是基于反馈环路的概念，包括如下措施：1）监测网路系统以便检测拥塞在何时何地发生2）把拥塞发生的信息传送到可采取行动的地方3）调整网络系统的行动以解决出现的问题。 拥塞控制方法因特网建议标准RFC2581定义了进行拥塞控制的四种算法，即慢开始（Slow-start)、拥塞避免（Congestion Avoidance)、快重传（Fast Retransmit）和快恢复（Fast Recovery）。我们假定：1）数据是单方向传送，对方只传送确认报文。2）接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定。 1. 慢开始和拥塞避免发送报文段速率的确定，既要根据接收端的接收能力，又要从全局考虑不要使网络发生拥塞，这由接收窗口和拥塞窗口两个状态量确定。接收端窗口（Reciver Window)又称通知窗口（Advertised Window)，是接收端根据目前的接收缓存大小所许诺的最新窗口值，是来自接收端的流量控制。拥塞窗口 cwnd（Congestion Window）由发送端维持，是发送端根据自己估计的网络拥塞程度而设置的窗口值（发送窗口=拥塞窗口），是来自发送端的流量控制。 慢开始算法：1）当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引起网络拥塞2）比较好的方法是试探一下，即从小到达逐渐增大发送窗口，也就是由小到大逐渐增大拥塞控制窗口。可以这么理解，每经过一个传输轮次，拥塞窗口cwnd就加倍。一个传输轮次意思是：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。由此可以看出：慢开始算法的拥塞窗口的增长速度是指数级的。3）通常在刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段的MSS的数值。在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值，当rwind足够大的时候，为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量–慢开始门限ssthresh用法： cwnd &lt; ssthresh 时，使用慢开始算法；cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法；cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。 拥塞避免算法：1）TCP连接初始化，将拥塞窗口设置为12）执行慢开始算法，cwind按指数规律增长，直到cwind == ssthress开始执行拥塞避免算法，cwnd按线性规律增长3）当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤（2）执行。 2. 快重传和快恢复一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。 快重传算法首先要说明快重传算法的目的是让发送方尽早知道发生了个别报文段的丢失。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认。即使收到了失序的报文段也要立即发出对已经收到的报文段的重复确认。如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时。 慢开始算法只是在TCP建立时才使用。 快恢复算法1）当发送方连续收到三个重复ACK时，就执行 “乘法减小” 算法，把慢开始门限设置为拥塞窗口的一半，这是为了预防网络发生拥塞2）由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把cwnd值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法，拥塞窗口线性增大。 由此总结：在拥塞避免阶段，拥塞窗口是按照线性规律增大的，这常称为加法增大AI(Additice Increase)。而一旦出现超时或3个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值，这常称为“乘法减小”MD(Multiplication Decrease)。二者合在一起就是所谓的AIMD算法。 题外话：在我看到快恢复算法的时候，产生了这样一个疑问：仅仅是丢失了一个报文段，为什么需要降低门限值、拥塞窗口值，而不是按照当前的进度、速度继续传呢？ 经过反复看书思考，我得出的结论是：丢失了一个报文段意味着即将发生拥塞，但是当前还没有拥塞。为了避免发送方错误地开启慢开始算法，拥塞窗口cwnd的值又设置为1，进而降低传输效率，于是采用快恢复算法调整门限值，使用拥塞避免算法来尽可能规避拥塞，达到兼顾效率和拥塞控制的目的。不知道想的对不对。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输控制协议TCP概述]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[最近在看《计算机网络》这本书，感觉写的挺好的。现在学到了TCP部分，我对TCP部分做了笔记，记录了一些重点，也记录了一些自己的想法，在此分享。 TCP最主要的特点 TCP是面向连接的运输层协议。 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。 TCP提供可靠交付的服务。无差错、不丢失、不重复，并且按序到达。 TCP提供全双工通信。TCP允许双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。 TCP是面向字节流的。这点不像UDP那样面向报文，对应用层交下来的报文 “既不合并，也不拆分” 。TCP只是把它们都看作是一连串无结构的字节流，并不了解所传送的字节流的含义，接收时的数据块跟发送时数据块数量可能不一样，但是总数据不会缺失。例如可能发送方应用程序交个发送方TCP有10个数据块，但接收方TCP可能只用了5个数据块就把收到的字节流交付上层的应用程序，虽然总共的字节流是一样的。将字节流还原成有意义的数据的任务，就交给应用层来完成。 套接字socketTCP把连接作为最基本的抽象。 TCP连接的端点叫做套接字(socket)或插口。根据RFC 793的定义：端口号拼接到IP地址即构成了套接字。因此，套接字的表示方法是在点分十进制的IP地址后面写上端口号，中间用冒号或逗号隔开。即： 套接字socket = (IP地址 : 端口号) 每一条TCP连接唯一的被通信两端的两个端点（即两个套接字）所确定。即： TCP连接 ::= {socket1, socket2} = {IP1:port1}, {IP2:port2} 需要注意的是，同一个名词socket可能有不同的意思，此处的socket仅仅是TCP连接的端点。 TCP报文段的首部格式如图为TCP报文段的首部格式。 首部固定部分各字段意义如下： 1）源端口和目的端口各占2个字节，分别写入源端口和目的端口。 2） 序号占4字节。序号范围是[0，232 - 1]，共232（即4294967296）个序号。序号增加到232-1后，下一个序号就又回到0。也就是说，序号使用mod 232运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是301，而接待的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。 3） 确认号占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。 总之：若确认号 = N，则表明：到序号N-1为止的所有数据都已正确收到。 4） 数据偏移占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。 5） 保留占6位，保留为今后使用，但目前应置为0 。下面有6个控制位，用来说明本报文段的性质。 6） 紧急URG（URGent）当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。 当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。 7） 确认ACK（ACKnowledgment）仅当ACK = 1时确认号字段才有效，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。 8） 推送 PSH（PuSH）当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。 9） 复位RST（ReSeT）当RST=1时，表名TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。 10） 同步SYN（SYNchronization）在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。 11） 终止FIN（FINis，意思是“完”、“终”）用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。 12） 窗口占2字节。窗口值是[0，216-1]之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值被视为接收方让发送方设置其发送窗口的依据。 例如，发送了一个报文段，其确认号是701，窗口字段是1000.这就是告诉对方：“从701算起，我（即发送方报文段的一方）的接收缓存空间还可接受1000个字节数据（字节序号是701~1700），你在给我发数据时，必须考虑到这一点。” 总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。 13） 检验和占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6,则相应的伪首部也要改变。 14） 紧急指针占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。 15） 选项长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节。 TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Size）。注意MSS这个名词含义。MSS是每一个 TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。 为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，至少要加上40字节的首部（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）才能组装成一个IP数据报。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。 因此，MSS应尽可能大些，只要在IP层传输时不需要分片就行。由于IP数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要的分片的MSS，如果改走另一条路径就可能需要进行分片。因此最佳的MSS是很难确定的。在连接过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传输数据，两个传送方向可以有不同的MSS值。若主机未填写这一项，则MSS的默认值是536字节长。因此，所有在互联网上的主机都应该接受的报文段长度是536+20（固定首部长度）=556字节。 后来又增加了几个选项如窗口扩大选项、时间戳选项、选择确认选项等。 窗口扩大选项是为了扩大窗口。我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。 窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2(16+14)-1=230-1。窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S=0选项，使窗口大小回到16。 时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个概念： 第一、 用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。 第二、 用于处理TCP序号超过 232 的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加 232个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。例如，当使用1.5Mbit/s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit/s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。 可靠传输的工作原理TCP发送的报文段是交给IP层传送的，但IP层只能提供尽最大努力交付，也就是说，TCP下面的网络提供的是不可靠的传输。因此TCP必须采取适当的措施才能使得两个运输层之间的通信变得可靠。为此就有下面的协议。 停止等待协议 无差错情况 A发送分组给B，发完暂停发送，等待B的确认。B收到了就向A发送确认，A在收到了B的确认后，就再发送下一个分组。 出现差错情况 B在接收时出了差错，就丢弃掉出错部分，或许分组在传输中丢失掉了，这时B不会发送任何信息。可靠传输协议设计为：A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢了，因而重传前面发送过的分组。这叫做超时重传。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。 应注意： A在发送完一个分组后，必须暂时保留已发送分组的副本（在发生超时重传时使用）。只有在收到相应的确认后才能清楚暂时保留的分组副本； 分组和确认分组必须编号。如此才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认； 超时计数器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。 确认丢失和确认迟到 确认丢失A在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了。因此A在超时计时器到期后就要重传分组。此时B又收到了A发来的重复分组，这时应采取两个行动：第一，丢弃这个重复的分组，不用向上交付；第二，向A发送确认。 确认迟到B对分组的确认迟到了，A会收到重复的确认，对重复的确认的处理是：收下后就丢弃。B同样要丢弃重复的分组，并重传确认分组。 A最终总会收到对所有发出的分组的确认。如果A不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。 向上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。像上述的这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat Request)。意思是重传的请求是自动进行的。接受方不需要请求发送方重传某个出错的分组。 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断的传送。 当使用流水线传输，就要使用下面的连续ARQ协议和滑动窗口协议。 连续ARQ协议发送方维持一个发送窗口，一次把窗口内所有分组全部发送出去，不必收到确认后再发送下一个。每收到一个确认，发送窗口就往前移动一个分组。 接受方一般是累计确认的方式。在收到几个分组后，对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已经正确收到了。 累计确认的优点是：容易实现，即使确认丢失也不用重传； 缺点是：不能向发送方反映出接收方已经正确接收到的所有分组的信息。例如，如果一共发送了5个分组，由于某些原因第3个分组丢失了，这时接收方只能发送到第2个分组的确认信息，发送方无法得知后三个分组是否送达，于是只好把这三个重传一次，称为 Go-back-N（回退N）。可见当通信质量不好的时候，会出现重传很多次的情况，带来不好的影响。 滑动窗口协议TCP的滑动窗口协议以字节为单位。若假定A收到了B发来的确认报文段，其中窗口是20字节，确认号是31（这表明B期望收到的下一个序号为31，而序号30为止的数据已经收到了）。根据这两个数据，A构造出自己的发送窗口，即从31到50的窗口。 发送窗口是什么？它表示，在未收到B的确认的情况下，A可以连续把窗口内的数据发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。 假设缓存窗口序号是从左到右依次增大的，那么左边设为窗口后沿，右边为窗口前沿，那么窗口后沿后边的部分表示已发送且已确认，前沿前边的部分表示不允许发送，因为接受方窗口不包括这里，没有生成对此的缓存。 发送窗口的位置由窗口前沿和后沿共同确认。其后沿变化有两种情况，即不动（没有收到新的确认）和前移（收到了新的确认）。后沿不可能向后端移动，因为后沿之后的数据均已经被确认过了。前沿一般是不断向前移动的，但也有可能不动，比如：一种是没有收到新的确认，对方通知的窗口大小不变；第二种是收到了新的确认，同时对方通知的窗口也缩小了，恰好保持前沿不动。前沿也有可能向后收缩（对方通知的窗口缩小了），但是TCP标准不推荐这么做，前面发送过，再进行取消，会产生一些错误。 发送窗口始终进行“发送-接收确认-调整窗口-发送“的过程。但是存在一些特殊情况，如：A发送窗口所有数据都发送给了B，B也返回了确认，但是所有确认都滞留在网络中。A没有收到确认一段时间后，就只好重传这些数据，即超时重传，直到收到B的确认为止。 TCP的流量控制与拥塞控制可以参考我的另一篇文章：TCP流量控制与拥塞控制原理分析 TCP的连接与连接释放可以参考我的另一篇文章：TCP知识点总结]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TCP的学习总结]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2FTCP%E3%80%81UDP%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、TCP和UDP的区别（1）TCP面向连接，UDP无连接；（2）TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证；（3）TCP传输速度慢；UDP速度快（4）每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信（5）TCP对系统资源要求较多，UDP对系统资源要求较少。（6）TCP的逻辑通信信道是全双工的可靠信道，UDP是不可靠信道。（7）UDP没有拥塞机制，因此网络出现拥塞不会使源主机的发送速率降低。（8）TCP首部开销20字节；UDP的首部开销小，只有8个字节；（9）UDP面向报文。 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP； FlashFXP，用的FTP； Outlook，用的POP、SMTP； Putty，用的Telnet、SSH； QQ文件传输 … 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频…有些应用场景对可靠性要求不高会用到UDP，比如长视频，要求速率 2、TCP三次握手四次挥手2.1 建立连接协议（三次握手）（1）客户端发送一个带SYN标志位、seq的TCP报文到server。这是三次握手过程中的报文1。此时client进入SYN_SEND状态。（2） server端回应client的报文，是三次握手中的第2个报文。这个报文同时带ACK（确认字符）标志、SYN标志、ack（=收到来自客户端的seq+1）、seq（server自己的）。因此它表示对刚才client SYN报文的回应。此时server进入SYN_RECV状态。（3） 客户必须再次回应服务段一个包括ACK、ack（=来自server的seq+1）、seq（第一次握手的seq+1）的报文，这是报文段3。此时双方进入ESTABLISHED状态。名词解释： 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 SYN：属于一个标志位，为1时代表这是一个连接请求（当ACK=0）或连接接受响应（当ACK=1）报文；SYN这个标志位只有在TCP建立连接时才会被置1，握手完成后SYN标志位被置0。 ACK：只在响应中出现。占1位，仅当ACK=1时，ack才有效。ACK=0时，ack无效。 2.2 连接终止协议（四次挥手）因为TCP连接是全双工的，因此每一个方向都必须单独进行关闭。这原则是当一方完毕它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN仅仅意味着这一方向上没有数据流动。一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将运行主动关闭。而还有一方运行被动关闭。流程： （1） 主机1发送FIN和seq。请求关闭主机1到主机2的数据传送（报文段4）。此时状态变化： 1：FIN_WAIT1 （2） 主机2收到这个FIN。它发回一个ACK、ack（收到的seq加1）、seq（报文段5）。这一步代表主机2同意关闭连接，但连接并没有关闭，因为主机2可能还有数据没发完，为此需要等待。此时状态变化：2：CLOSE_WAIT | 1：FIN_WAIT2 （3） 主机2发完剩余数据，准备关闭与主机1的连接，并发送一个FIN给主机1（报文段6）。进入LAST-ACK（最后确认）状态。如果没收到主机1的回复，会进行超时重传的。 （4） 主机1收到主机2回复，知道它的数据发送完了。于是发回ACK报文确认收到，告诉主机2你可以关了。并将ack设置为收到序号加1（报文段7）。这样一来主机2收到后就安心关闭连接了。此时状态变化： 1：TIME_WAIT | 2：CLOSED。 这样四次挥手就完成了。不过别忘了，主机1还在TIME_WAIT状态。他需要等待2MSL的时间，如果在这段时间又收到来自主机2的FIN+ACK报文（报文段6），就会再发送ACK报文回去，直至过了2MSL且再无回音，就关掉。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指任何IP数据报能够在因特网上存活的最长时间，2MSL就是一个发送和一个回复所需的最大时间。 名词解释： FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 3. 一些常见的问题 为什么要进行time wait，为什么要等2MSL？为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。没收到确认的话，B是会超时重传这个FIN+ACK报文段的，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态。 为什么连接的时候是三次握手，关闭的时候却是四次握手？因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，可能还有数据要传，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，是不能一起发送的。故需要四步握手。 为什么要三次握手？不行。因为握手是为了确认双方收发功能均正常，进而确认可以同步序列号。第一次client -&gt; server，server可以确认client发是好的；第二次server -&gt; client，client可以确认自己收发是好的，对方收发也是好的；第三次client -&gt; server，server可以确认自己收发是好的，对方也是。为什么可以这么确认？是因为这收发之间都存在着校验。第一次server收到client的连接请求，推测其可能要发起连接，于是按规定返回了client要求的ack（收到的seq+1），并且发了自己的seq，看对方是不是真想连接；第三次client收到并返回的过程类似第二步。如此，就完成了对接。为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议基础]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2FHTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写。HTTP协议工作于客户端-服务端架构之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器在接收到的请求后，向客户端发送响应信息。 HTTP特点 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。 灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。常用的请求方法 GET: 向指定的资源请求数据。 POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和或已有资源的修改。 HEAD: 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 PUT: 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE: 请求服务器删除指定的页面。 post和get的区别：都包含请求头请求行，post相比之下多了请求body。get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。 报文构成请求报文构成http请求由请求行（request line）、请求头部（header）、空行和请求数据构成。请求行以请求方法开头，后面跟着请求的URL和协议的版本，均以空格分开。 响应报文构成HTTP响应也由状态行、消息报头、空行和响应正文构成。 状态码响应状态码：访问一个网页时，浏览器会向web服务器发出请求。此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求。 状态码分类以下是状态码的分类。123451XX- 信息型，服务器收到请求，需要请求者继续操作。2XX- 成功型，请求成功收到，理解并处理。3XX - 重定向，需要进一步的操作以完成请求。4XX - 客户端错误，请求包含语法错误或无法完成请求。5XX - 服务器错误，服务器在处理请求的过程中发生了错误。 常见状态码12345678200 - OK 客户端请求成功301 - 资源（网页等）被永久转移到其它URL302 - 临时跳转400 Bad Request - 客户端请求有语法错误，不能被服务器所理解401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用404 - 请求资源不存在，可能是输入了错误的URL500 - 服务器内部发生了不可预期的错误503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 客户端浏览器如何解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;2、解析出 IP 地址后，若有端口号则解析出端口号，无则根据该 IP 地址和默认端口 80，和服务器建立TCP连接;3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;5、释放 TCP连接;6、浏览器将该 html 文本并显示内容。 几个概念DNS域名解析服务。将主机名转换为IP地址。端口号http://localhost:8080 8080就是端口号。HTTP的URL中没有端口号时，可以假设默认端口号时80。有了IP地址和端口号，客户端就可以很方便地通过TCP/IP进行通信了。代理代理是位于客户端和服务器之间的HTTP中间实体。接收所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。缓存缓存HTTP的仓库，使常用页面的副本可以保存在离客户端更近的地方。隧道隧道是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。常见用途是通过HTTP连接承载加密的安全套接字层（SSL）流量，这样SSL流量就可以穿过只允许Web流量通过的防火墙了。 HTTP和HTTPS的区别HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。HTTPS和HTTP的区别主要如下：1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 参考文章：https://blog.csdn.net/weixin_41835916/article/details/81590826]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见七大排序的Java实现]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0(%E6%8F%92%E5%85%A5%2B%E5%B8%8C%E5%B0%94%2B%E5%86%92%E6%B3%A1%2B%E5%BF%AB%E9%80%9F%2B%E9%80%89%E6%8B%A9%2B%E5%BD%92%E5%B9%B6)%2F</url>
    <content type="text"><![CDATA[之前学习C语言时学过各类基础排序，现在用Java来再回顾一遍。这一篇主要是写一下规范的代码。 一、排序相关的基本概念 排序其实是一个相当大的概念，主要分为两类：内部排序和外部排序。而我们通常所说的各种排序算法其实指的是内部排序算法。内部排序是基于内存的，整个排序过程都是在内存中完成的，而外部排序指的是由于数据量太大，内存不能完全容纳，排序的时候需要借助外存才能完成（常常是某一部分已经计算过的数据移出内存让另一部分未被计算的数据进入内存）。而本篇文章将主要介绍内部排序中的几种常用排序算法：为了测试方便，我定义了生成随机数组的Const类和打印输出的print函数。Const类如下： 12345678910public class Const &#123; public int a[] = new int[50]; public Const()&#123; Random random = new Random(); for( int i=0; i&lt;a.length; i++ )&#123; a[i] = random.nextInt(100); &#125; &#125;&#125; 二、插入类排序1.直接插入插入类排序算法的核心思想是，在一个有序的集合中，我们将当前值插入到适合位置上，使得插入结束之后整个集合依然是有序的。代码如下：123456789101112131415161718/** * 插入排序 * @param array */ public static void InsertSort(int[] array)&#123; int i, j, key; for( i=1; i&lt;array.length; i++ )&#123; key = array[i]; j = i - 1; //取当前位置值，与已经排序好的那一部分由大到小进行比较，将其挪到正确的位置 while ( j&gt;=0 &amp;&amp; key&lt;array[j] )&#123; array[j+1] = array[j]; j--; &#125; array[j+1] = key;//在正确的位置插入key值 &#125; print(array); &#125; 2、二分插入原理是二分查找到合适位置再进行插入。1234567891011121314151617181920212223242526272829/** * 二分插入排序 * @param array */ public static void halfInsertSort(int[] array)&#123; for( int i=1; i&lt;array.length; i++ )&#123; int mid, low, high, key; low = 0; high = i-1; key = array[i]; //这个循环之后，要插入的地方为low while ( low&lt;=high )&#123; mid = (low+high)/2; if( key==array[mid] )&#123; low = mid; break; &#125;else if( key&gt;array[mid] )&#123; low = mid + 1; &#125;else&#123; high = mid - 1; &#125; &#125; //将已排序部分low之后的都向后移动一位 for( int k=i-1; k&gt;=low; k-- )&#123; array[k+1] = array[k]; &#125; array[low] = key; &#125; print(array); &#125; 3、希尔排序希尔排序算法使用一个距离增量来切分子序列，使每个子序列都有序。当距离增量变小的时候，序列的个数也会变少，但是这些子序列的内部都基本有序，当对他们进行直接插入排序的时候会使得效率变高。一旦距离增量减少为1，那么子序列的个数也将减少为1，也就是我们的原序列，而此时的序列内部基本有序，最后执行一次直接插入排序完成整个排序操作。12345678910111213141516171819202122/** * 希尔排序 * @param array */ public static void shellSort(int[] array)&#123; int len = array.length; int step = len/2;//步长 while( step&gt;0 )&#123; for( int i=step; i&lt;len; i++ )&#123; int j = i; //while循环 --对由步长分成的各数组进行直接插入排序 while ( j&gt;=step &amp;&amp; array[j]&lt;array[j-step] )&#123; int temp = array[j]; array[j] = array[j-step]; array[j-step] = temp; j -= step; &#125; &#125; step /= 2; &#125; print(array); &#125; 三、交换类排序1、冒泡排序冒泡排序通过两两比较，每次将最大或者最小的元素移动到整个序列的一端。123456789101112131415161718/** * 冒泡排序 * @param array */ public static void bubbleSort(int[] array)&#123; int temp = 0; //每次将最大的放到最后，需要进行length-1次 for( int i=0; i&lt;array.length-1; i++ )&#123; for( int j=1; j&lt;array.length-1-i; j++ )&#123; if( array[j]&lt;array[j-1] )&#123; temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; &#125; &#125; &#125; print(array); &#125; 2、快速排序快速排序的基本思想是，从序列中任选一个元素，但通常会直接选择序列的第一个元素作为一个标准，所有比该元素值小的元素全部移动到他的左边，比他大的都移动到他的右边。该排序算法是目前为止，内部排序中效率最高的排序算法。12345678910111213141516171819202122232425262728293031323334/** * 快速排序 * @param array */ public static void quickSort(int[] array)&#123; int low = 0; int high = array.length-1; qSort(array, low, high); print(array); &#125; private static void qSort(int[] array, int low, int high)&#123; if( low&lt;high )&#123; int pos = oneQuickSort(array, low, high); qSort(array, low, pos-1); qSort(array, pos+1, high); &#125; &#125; private static int oneQuickSort(int[] array, int low, int high)&#123; int key = array[low]; while ( low&lt;high )&#123; while ( low&lt;high &amp;&amp; array[high]&gt;=key )&#123; high--; &#125; array[low] = array[high]; while ( low&lt;high &amp;&amp; array[low]&lt;=key )&#123; low++; &#125; array[high] = array[low]; &#125; array[low] = key; return low; &#125; 四、选择类排序选择类排序的基本思想是，每一趟会在n个元素中比较n-1次，选择出最大或者最小的一个元素放在整个序列的端点处。1234567891011121314151617181920/** * 直接选择排序 * @param array */ public static void selectionSort(int[] array)&#123; for( int i=0; i&lt;array.length; i++ )&#123; int minIdx = i; //记录最小值的位置 for( int j=i+1; j&lt;array.length; j++ )&#123; if( array[j]&lt;array[minIdx] )&#123; minIdx = j; &#125; &#125; if( minIdx!=i )&#123; int temp = array[i]; array[i] = array[minIdx]; array[minIdx] = temp; &#125; &#125; print(array); &#125; 五、归并类排序算法1234567891011121314151617181920212223242526272829303132333435363738/** * 归并排序 * @param array */ public static void mergeSort(int[] array)&#123; int len = array.length; int[] arrayTemp = new int[len]; mSort(array, 0, len-1, arrayTemp); print(array); &#125; private static void mSort(int[] array, int low, int high, int[] arrayTemp)&#123; if( low &lt; high ) &#123; int mid = low + (high-low)/2; //分界 mSort(array, low, mid, arrayTemp); mSort(array, mid+1, high, arrayTemp); mergeTwoArray(array, low, mid, high, arrayTemp); &#125; &#125; private static void mergeTwoArray(int[] array, int low, int mid, int high, int[] arrayTemp)&#123; int i=low, j=mid+1; int current = 0; while ( i&lt;=mid &amp;&amp; j&lt;=high )&#123; if( array[i]&lt;array[j] )&#123; arrayTemp[current++] = array[i++]; &#125;else&#123; arrayTemp[current++] = array[j++]; &#125; &#125; while( i&lt;=mid )&#123; arrayTemp[current++] = array[i++]; &#125; while ( j&lt;=high )&#123; arrayTemp[current++] = array[j++]; &#125; System.arraycopy(arrayTemp,0,array,low,current); &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery和ajax使用.md]]></title>
    <url>%2Funcategorized%2FjQuery%E5%92%8Cajax%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JSP FileUpload实现文件上传]]></title>
    <url>%2FJava%2FWeb%2FJSP-FileUpload%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[文件上传的条件 表单必须是post提交方式 表单中必须有文件上传项，文件上传项必须有name属性和值 表单的enctype属性必须设置为multipart/form-data 文件上传基本操作数据接收：通过使用fileupload jar包的Common-FileUpload组件完成文件上传基本步骤： 创建一个 磁盘文件项工厂 的对象DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory(); 创建一个核心解析类ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory ); 解析request请求 —— parseRequest，返回一个List集合，List集合中存放的是FileItem对象（每一个表单项都是一个FileItem对象）List&lt;FileItem&gt; list = servletFileUpload.parseRequest(request); 遍历集合，获得每个FileItem，判断是表单项还是文件上传项fileItem.isFormField(): 返回是普通的文件表单项还是文件上传项fileItem.getFieldName(): 获得表单项的name属性值fileItem.getString(“UTF-8”): 获取表单的文本值，可设置UTF-8解决中文乱码 获得文件名：String filename = fileItem.getName(); 通过自定义工具类获得唯一文件名：String uuidfilename = UploadUtils.getUUIDFileName(filename);注：UploadUtils类是自定义工具类，具体实现是： 123456789101112131415public class UploadUtils &#123; /* * 生成唯一文件名 * */ public static String getUUIDFileName(String fileName) &#123; int idx = fileName.lastIndexOf("."); String extention = fileName.substring(idx);//扩展名 String uuidFileName = UUID.randomUUID().toString().replace("-", "")+extention; return uuidFileName; &#125; public static void main(String[] args) &#123; System.out.println(getUUIDFileName("1.jpg")); &#125;&#125; 输入流获得文件上传的数据：InputStream is = fileItem.getInputStream(); 得到文件要上传的路径url = this.getServletContext().getRealPath(&quot;/upload&quot;)+&quot;//&quot;+uuidfilename; 输入流对接输出流123456789OutputStream os = new FileOutStream(url);//输出流目标为urlint len = 0;byte[] b = new byte[1024];while((len=is.read(b)) != -1)&#123;//读取输入流到b中os.write(b,0,len);//将b写入输出流中&#125;is.close();//关闭输入流os.close();//关闭输出流&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0050 Pow(x,n)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FLeetCode%200050%20Pow(x%2Cn)%2F</url>
    <content type="text"><![CDATA[题目实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 输入: 2.00000, 10输出: 1024.00000 示例 2: 输入: 2.10000, 3输出: 9.26100 示例 3: 输入: 2.00000, -2输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 题解用的递归法，log n123456789101112131415161718192021222324252627class Solution &#123; public double myPow(double x, int n) &#123; boolean isNagetive = false; if( n&lt;0 ) &#123; n = -n; isNagetive = true; &#125; if( isNagetive ) &#123; return 1/pow(x, n); &#125;else &#123; return pow(x, n); &#125; &#125; public static double pow(double x, int n) &#123; double res = 1.0; if( n==0 ) &#123; return 1.0; &#125;else if( n==1 ) &#123; return x; &#125;else if( n%2==0 ) &#123; res = pow(x*x, n/2); &#125;else&#123; res = pow(x*x, n/2) * x; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0109 有序链表转换二叉搜索树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FLeetCode%200109%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。示例： 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：123456&gt; 0&gt; / \&gt; -3 9&gt; / /&gt; -10 5&gt; 题解这道题类似归并排序，需要每次都把链表分为尽可能等长的两部分，然后分别对这两部分再进行生成二叉树的操作。可以用快慢指针，具体实现是：设置快慢指针各一个，慢指针步进为1，快指针步进为2，循环条件是快指针不为空且其子节点不为空。这样快指针走的长度是慢的2倍，可以保证每次循环都找到了链表的中心节点（平衡二叉树需要找中心节点）。每次循环后链表被分为： 0-premid、slow、slow.next-最后一个 这三部分。Java代码如下：123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if( head==null ) return null; if( head.next==null ) return new TreeNode(head.val); ListNode slow = head; ListNode fast = head; ListNode premid = null; while( fast!=null &amp;&amp; fast.next!=null ) &#123; premid = slow; slow = slow.next; fast = fast.next.next; &#125; premid.next = null; TreeNode root = new TreeNode(slow.val); root.left = sortedListToBST(head); root.right = sortedListToBST(slow.next); return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse建立web项目时忘了生成xml文件的解决办法]]></title>
    <url>%2F%E5%8F%91%E7%8E%B0%2Feclipse%E5%BB%BA%E7%AB%8Bweb%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%BF%98%E4%BA%86%E7%94%9F%E6%88%90xml%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[刚学web没多久，建立项目时忘了去勾选建立web.xml文件的选项。当我写了好多代码，接下来需要修改这个文件的时候才发现，我没有生成它…接下来在摸索中找到了解决办法。首先在创建的项目上右键，找到Java EE Tools，然后点击Generate Deployment Descriptor Stub，如下图（我的已经生成了所以是灰色）。完了之后会发现，web.xml躺在WEB-INF文件夹下~ （完）]]></content>
      <categories>
        <category>发现</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-EL表达式和JSTL标签库]]></title>
    <url>%2FJava%2FWeb%2FJava-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CJSTL%E6%A0%87%E7%AD%BE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[关于EL表达式EL表达式全名为Expression Language，是一种为了在JSP中计算和输出Java对象的简单语言。基本语法： ${expression}以上语句中，expression为有效的表达式。该表达式可以和静态文本混合，还可以与其他表达式结合成为更大的表达式。 EL四个作用域对象如果我们在jsp页面调用Servlet的数据信息时，不写这个范围，那么EL就会从在小到大的范围内依次去寻找我们调用的这些数据。（因此最好写上） EL表达式输出语法：${[作用域.]属性名[.子属性]}EL支持绝大多数对象输出，本质是执行toString方法例： ${title}${requestScope.student.name}${emp.salary + 300}${ 1&lt;=3 &amp;&amp; 2&gt;4 } 获取数据：我们可以使用EL的内置对象param来简化获取url或者请求体中的数据语法：${param.参数名}例如当url是 https://class.makersy.com/lesson?mid=17331在Servlet中，我们用request.getParameter(“mid”)获取而现在可以用${param.mid}获取了其实，${param.参数名}就是request.getParameter（“参数名”);的简化形式 JSTL标签库使用JSTL表达式JSTL是JSP标准标签库的简称，它提供的标签能一定程度上代替Java代码，例如&lt;c:forEach/&gt;标签能实现Java语言中的循环功能。 使用前：1.下载jstl.jar和standard.jar包 2将这两个包复制到web-inf\lib 目录下 3.在JSP页面中添加指令，例如： 核心标签库初始化&lt;%@ taglib uri = &quot;http://java.sun.com/jsp/jstl/core&quot; prefix = &quot;c&quot; %&gt;或格式标签库初始化&lt;%@ taglib uri = &quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix = &quot;fmt&quot; %&gt; JSTL标签库JSTL有五个标签库，分别是：核心标签库、格式标签库、函数标签库、SQL标签库、XML标签库。主要用前两者。 核心标签库主要完成JSP页面常用功能，包括JSTL表达式标签、URL标签、流程控制标签和循环标签等。其中，表达式标签有 和显示操作有关的&lt;c:out value=&quot; ${ news.title }&quot;/&gt;输出属性的值 数据库中给出的标签可以显示；&lt;c:set var=&quot;uid&quot; value=&quot;admin&quot; scope=&quot;request&quot;/&gt; 存入变量,把uid的变量存入request中;&lt;c:remove var=&quot;uid&quot; value=&quot;admin&quot; scope=&quot;request&quot;/&gt;移除变量 把request中的uid的变量移除. 实现程序逻辑相关的c:foreach标签&lt;c:forEach var=&quot;对象&quot; items=”保存在request中的数组&quot; varStatus=&quot;status&quot;&gt;循环的的变量&lt;c:forEach /&gt;&lt;c:forEach&gt;标签具有以下一些属性： var：迭代参数的名称。在迭代体中可以使用的变量的名称，用来表示每一个迭代变量。类型为String。 items：要进行迭代的集合。对于它所支持的类型将在下面进行讲解。 varStatus：迭代变量的名称，用来表示迭代的状态，可以访问到迭代自身的信息。 begin：如果指定了items，那么迭代就从items[begin]开始进行迭代；如果没有指定items，那么就从begin开始迭代。它的类型为整数。 end：如果指定了items，那么就在items[end]结束迭代；如果没有指定items，那么就在end结束迭代。它的类型也为整数。 step：迭代的步长。 &lt;c:forEach&gt;标签的items属性支持Java平台所提供的所有标准集合类型。此外，您可以使用该操作来迭代数组（包括基本类型数组）中的元素。它所支持的集合类型以及迭代的元素如下所示：​ java.util.Collection：调用iterator()来获得的元素。 java.util.Map：通过java.util.Map.Entry所获得的实例。​ java.util.Iterator：迭代器元素。​ java.util.Enumeration：枚举元素。​ Object实例数组：数组元素。​ 基本类型值数组：经过包装的数组元素。​ 用逗号定界的String：分割后的子字符串。​ javax.servlet.jsp.jstl.sql.Result：SQL查询所获得的行。​ 不论是对整数还是对集合进行迭代， &lt;c:forEach&gt;的varStatus属性所起的作用相同。和var属性一样，varStatus用于创建限定了作用域的变量（改变量只在当前标签体内起作用）。不过，由varStatus属性命名的变量并不存储当前索引值或当前元素，而是赋予javax.servlet.jsp.jstl.core.LoopTagStatus类的实例。该类包含了一系列的特性，它们描述了迭代的当前状态，如下这些属性的含义如下所示：​ current：当前这次迭代的（集合中的）项。​ index：当前这次迭代从0开始的迭代索引。​ count：当前这次迭代从1开始的迭代计数。​ first：用来表明当前这轮迭代是否为第一次迭代，该属性为boolean类型。​ last：用来表明当前这轮迭代是否为最后一次迭代，该属性为boolean类型。​ begin：begin属性的值。​ end：end属性的值​ step：step属性的值​下面是一个使用的小例子，判断x的值并输出他所在的区间。123456789101112131415161718192021222324&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%request.setAttribute("x", "11");%&gt;&lt;c:choose&gt;&lt;c:when test="$&#123;x&gt;0 &amp;&amp; x&lt;=10 &#125;"&gt;&lt;h1 style="color:blue"&gt;1-10之间的整数&lt;/h1&gt;&lt;/c:when&gt;&lt;c:when test="$&#123;x&gt;10 &amp;&amp; x&lt;=20 &#125;"&gt;&lt;h1 style="color:lightcoral"&gt;11-20之间的整数&lt;/h1&gt;&lt;/c:when&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; 格式化日期1234567891011121314151617181920212223242526272829303132333435jstl日期格式化代码&lt;%@page import="java.util.Date"%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%request.setAttribute("amt", "1898923.234");request.setAttribute("now", new Date());request.setAttribute("html", "&lt;a href='index.html'&gt;index&lt;/a&gt;");request.setAttribute("nothing", null);%&gt;&lt;!-- formatDate pattternyyyy - 四位年MM = 两位月dd = 两位日HH - 24小时制hh - 12小时制mm - 分钟ss - 秒数SSS - 毫秒--&gt;&lt;h2&gt;&lt;fmt:formatDate value="$&#123;requestScope.now &#125;" pattern="yyyy年MM月dd日HH时mm分ss秒SSS毫秒" /&gt; &lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>EL表达式</tag>
        <tag>JSTL标签库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Servlet和JSP]]></title>
    <url>%2FJava%2FWeb%2F%E5%85%B3%E4%BA%8EServlet%2F</url>
    <content type="text"><![CDATA[请求转发和响应重定向 请求转发： 是服务器跳转，只产生一次请求request.getRequestDispatcher(url).forward(request,response） 响应重定向： 是浏览器端跳转，会产生两次请求地址栏会变成最后的url （处理完成第一个请求之后返回一个特殊的响应给浏览器由浏览器重新发起另一个请求到新的资源）response.sendRedirect(url);HTTP状态码打开网页可根据出现的状态码来判断处于什么状态。 ContentType的作用ContentType决定浏览器采用何种方式对相应体进行处理 CookieCookie是浏览器保存在本地的文本内容Cookie常用于保存登录状态、用户资料等小文本Cookie具有时效性，Cookie内容会伴随请求发送给Tomcat1234567891011121314151617181920212223242526272829//Cookie部分doGet函数protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("用户登录成功！"); Cookie cookie = new Cookie("user", "admin"); cookie.setMaxAge(60*60*24*7);//有效期七天内有效 response.addCookie(cookie); response.getWriter().println("login success");&#125;//使用cookie的函数protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie[] cookies = request.getCookies(); if( cookies==null ) &#123; response.getWriter().println("user not login"); &#125; String user = null; for( Cookie cookie : cookies ) &#123; System.out.println(cookie.getName() + ":" + cookie.getValue()); if( cookie.getName().equals("user") ) &#123; user = cookie.getValue(); break; &#125; &#125; if( user == null ) &#123; response.getWriter().println("user not login"); &#125;else &#123; response.getWriter().println("user : " + user); &#125;&#125; SessionSession(用户会话)： 用于保存于“浏览器窗口”对应的数据。它与Cookie的不同是：Cookie保存的数据在客户端，二Session保存的数据在服务器。 session是与窗口绑定的，保存在tomcat服务器的数据是30分钟. Session通过浏览器Cookie的SessionId提取对应用户的数据 浏览器第一次向服务器发送请求时，服务器在内存中开辟一块儿空间用于存放这个会话的信息，并把这块空间的id（sessionId）返回给浏览器。浏览器将sessionId存放在cookie中，之后每次向服务器发起请求都会携带这个cookie，告知服务器当前的会话。 JavaWeb三大作用域对象 HttpServletRequest – 请求响应完毕就消失了。 HttpSession – 第一次请求被创建，默认30分钟没有被访问就被销毁。此时把浏览器关掉其实是将存储在cookie中的sessionid抛弃，并没有被销毁。 ServletContext web – 应用启动时被创建，重启或关闭时被销毁。 程序开发时，为了便于维护，能用小作用域对象就用小作用域对象。 JSP九大内置对象 更新中，未完待续…]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 951 翻转二叉树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FLeetCode-951-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。 只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。 编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。 示例： 输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]输出：true解释：We flipped at nodes with values 1, 3, and 5. 提示：每棵树最多有 100 个节点。每棵树中的每个值都是唯一的、在 [0, 99] 范围内的整数。 题解先说一句，我没写出来。看到这个题我首先想的是怎么实现将某些节点交换左右子节点，而某些不换，从而判断两棵树是否相等。于是写了交换子节点的函数和判断两棵树是否相等的函数。且不说可行性，光O(n)就够我喝一壶的。然后我看了下网上大佬的题解才懂。我的代码理解都写在注释里。。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean flipEquiv(TreeNode root1, TreeNode root2) &#123; //若有一个或两个为空，返回两节点是否相等。具体结果是：若均为空，返回true；若一个为空，返回false if(root1 == null || root2 == null)&#123; return root1 == root2; &#125; //若两节点的值都不相等，那么自然树也不相等 if(root1.val != root2.val)&#123; return false; &#125; /* 分别比较root1和root2的：左左、右右、左右、右左。 若是可以通过交换子节点来使两根节点下的树相等， 那么将这两个根节点的四个子节点顺序进行排列组合， 若有一种情况下是两边相等,那么就可以通过交换而得；否则就不可以。 */ return flipEquiv(root1.left, root2.left) &amp;&amp; flipEquiv(root1.right, root2.right) || flipEquiv(root1.left, root2.right) &amp;&amp; flipEquiv(root1.right, root2.left); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0102-二叉树的层次遍历]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FLeetCode-0102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。例如:给定二叉树: [3,9,20,null,null,15,7],​ 返回其层次遍历结果：[ [3], [9,20], [15,7]] 题解我的思路是每行的节点都从左到右用一个队列或链表来存储，每次取队列头部并弹出。如果该节点有非空的后代节点则再加入队列，直到队列为空时停止。代码如下:12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res=new LinkedList&lt;&gt;(); LinkedList&lt;TreeNode&gt; queue=new LinkedList&lt;TreeNode&gt;(); if(root==null) return res; queue.offer(root); while(!queue.isEmpty())&#123; int size=queue.size(); List&lt;Integer&gt; subres=new LinkedList&lt;&gt;(); for(int i=0;i&lt;size;i++)&#123; TreeNode tmp=queue.pop(); subres.add(tmp.val); if(tmp.left!=null) queue.offer(tmp.left); if(tmp.right!=null) queue.offer(tmp.right); &#125; res.add(subres); &#125; return res; &#125;&#125; 耗时最少的是用递归法做的123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; //递归实现 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); if(root==null) return res; recursionLevelOrder(root,0,res); return res; &#125; private void recursionLevelOrder(TreeNode root,int level,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(root==null) return; if(res.size()==level)&#123; List&lt;Integer&gt; subres=new ArrayList&lt;&gt;(); subres.add(root.val); res.add(subres); &#125;else&#123; res.get(level).add(root.val); &#125; recursionLevelOrder(root.left,level+1,res); recursionLevelOrder(root.right,level+1,res); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型修饰符volatile]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2F%E7%B1%BB%E5%9E%8B%E4%BF%AE%E9%A5%B0%E7%AC%A6volatile%2F</url>
    <content type="text"><![CDATA[今天看Java并发时，看到了一个新的关键字volatile，觉得有必要记一下。 基础概念​ 先补充一下概念：Java 内存模型中的可见性、原子性和有序性。可见性： 可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。 在 Java 中 volatile、synchronized 和 final 实现可见性。 原子性： 原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。 在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。 有序性： ​ Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。 volatile原理 百度该字条，其内容是： volatile是一个类型修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。 ​ 如果查阅一下英文字典，有关volatile的解释，你会得到最常用的解释是“易变的，不稳定的”。这也是volatile关键字的含义。 ​ Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 ​ 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。 而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 ​ 当一个变量定义为 volatile 之后，将具备两种特性： 1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。 2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。 volatile 性能： volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML文档编写及XPath表达式使用]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FXML%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99%E5%8F%8AXPath%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[XML简介XML是可扩展标记语言(Extensible Markup Language，XML)缩写，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。可以用于Java程序配置描述文件、保存产生的数据、网络间数据传输等。 XML语法&amp;结构XML文档结构 第一行需是XML文档声明 有且只有一个根节点 书写规则与HTML相同 标签名使用小写英文, 单词间用-分隔多级标签之间不要存在重名 对特殊符号使用实体引用或CDATA标签5种实体引用12345&amp;lt; &lt;&amp;gt; &gt;&amp;amp; &amp;&amp;apos; '&amp;quot; " CDATA标签:&lt;![CDATA[不希望由XML解析的文本数据]]&gt; XML语义约束语义约束的两种定义方式:DTD与XML SchemaDTD利用DTD中的&lt;！ELEMENT&gt;标签定义XML文档中允许出现的节点及数量例: &lt;!ELEMENT hr (employee)&gt;&lt;!ELMENT name(#PCDATA)&gt; 定义name标签体只能是文本使用描述符表达子节点数量+ 至少出现1个子节点* 可出现0…n个子节点?最多出现1个子节点在XML中使用&lt;!DOCTYPE&gt;标签来引用DTD文件。书写格式:&lt;!DOCTYPE 根节点 SYSTEM &quot;dtd文件路径&quot;&gt; Schema比DTD更复杂XML Schema提供了数据类型、格式限定、数据范围等特性&lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;声明文本是Schema&lt;element&gt;代表标签节点&lt;complexType&gt;复杂节点, 标签包含子节点时使用&lt;sequence&gt;子标签按顺序排列&lt;attribute&gt;设置属性标签属性:name= 属性名称type= 属性值类型use=”required” 属性必须存在minOccurs=”n” 最小出现次数maxOccurs=”n” 最大出现次数&lt;simpleType&gt;简单类型。 代替属性:type使用&lt;restriction&gt;限定数据类型base=”xx” 基本类型&lt;minInclusive value=&quot;&quot;&gt;最小数据范围&lt;maxInclusive value=&quot;&quot;&gt;最大数据范围在XML文本的根节点添加1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;Schema文件路径&quot; 属性来关联schema文本 Dom4jDom4j是java用来读取和操作xml文档的一种方式。DOM(Document Object Model) 文档对象模型把xml文档看做一个树结构Dom4j的含义和作用 将xml文件视为Document对象 将xml文件中的标签视为Element对象使用时需下载dom4j的jar包并导入。 XPath基本表达式nodename: 选取此节点的所有子节点/ 从根节点选取// 从匹配选择的当前节点选择文档中的节点. 当前节点.. 当前节点的父节点@ 选取属性谓语表达式[1] 第一个匹配的元素[last()] 最后一个匹配的元素[last()-1] 倒数第二个匹配的元素[position()&lt;3] 最前面两个匹配的元素[@lang] 选取所有拥有lang属性的元素[@lang=&#39;value&#39;] 选取所有包含lang属性且属性值为value的元素[price&gt;35.00] 选取price元素值大于35.00的元素 总结下面是我写的一个例子：XML文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- &lt;!DOCTYPE hr SYSTEM "NewFile.dtd"&gt; --&gt;&lt;!-- 人力资源管理系统 --&gt;&lt;hr xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="hr.xsd"&gt; //xml schema文件名为hr.xsd &lt;employee no="3309"&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;31&lt;/age&gt; &lt;salary&gt;4000&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;会计部&lt;/dname&gt; &lt;address&gt;b103&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt; &lt;employee no="3310"&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;salary&gt;4000&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;会计部&lt;/dname&gt; &lt;address&gt;b103&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt; &lt;employee no="3311"&gt; &lt;name&gt;张无忌&lt;/name&gt; &lt;age&gt;30&lt;/age&gt; &lt;salary&gt;3600&lt;/salary&gt; &lt;department&gt; &lt;department /&gt; &lt;dname&gt;人事部&lt;/dname&gt; &lt;address&gt;XX大厦-B105&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt;&lt;/hr&gt; xml语义约束–xml schema文件(.xsd)12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.org/hr" xmlns:tns="http://www.example.org/hr" elementFormDefault="qualified"&gt; &lt;element name="hr"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name="employee" minOccurs="1" maxOccurs="9999"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name="name" type="string"&gt;&lt;/element&gt; &lt;element name="age"&gt; &lt;simpleType&gt; &lt;restriction base="integer"&gt; &lt;minInclusive value="18"&gt;&lt;/minInclusive&gt; &lt;maxInclusive value="60"&gt;&lt;/maxInclusive&gt; &lt;/restriction&gt; &lt;/simpleType&gt; &lt;/element&gt; &lt;element name="salary" type="integer"&gt;&lt;/element&gt; &lt;element name="department"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name="dname" type="string"&gt;&lt;/element&gt; &lt;element name="address" type="string"&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;attribute name="no" type="string" use="required"&gt;&lt;/attribute&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt; 读xml1234567891011121314151617181920212223242526272829303132333435package hr;import java.util.List;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class Hrreader &#123; void readXml() &#123; String file = "d:/Eclipse/workplace/calculator/src/NewFile.xml"; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); //获取文档根节点，即hr标签 Element root = document.getRootElement(); List&lt;Element&gt; employees = root.elements("employee"); for( Element employee : employees ) &#123; Element name = employee.element("name"); String empName = name.getText(); System.out.println(empName); System.out.println(employee.elementText("age")); System.out.println(employee.elementText("salary")); &#125; &#125; catch (DocumentException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Hrreader reader = new Hrreader(); reader.readXml(); &#125;&#125; 写xml12345678910111213141516171819202122232425262728293031323334353637383940414243package hr;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.Writer;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class HrWriter &#123; public void WriteXml()&#123; String file = "d:/Eclipse/workplace/calculator/src/NewFile.xml"; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); Element root = document.getRootElement(); Element employee = root.addElement("employee"); employee.addAttribute("no", "3311");// Element name = employee.addElement("name");// name.setText("李想"); employee.addElement("name").setText("张无忌"); employee.addElement("age").setText("30"); employee.addElement("salary").setText("3600"); Element department = employee.addElement("department"); department.addElement("department"); department.addElement("dname").setText("人事部"); department.addElement("address").setText("XX大厦-B105"); Writer writer = new OutputStreamWriter(new FileOutputStream(file), "UTF-8"); document.write(writer); writer.close(); &#125; catch (Exception e) &#123; // TODO: handl exception e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; HrWriter hrWriter = new HrWriter(); hrWriter.WriteXml(); &#125;&#125; 利用xpath进行xml文件的各种查找，类似数据库的查找语句12345678910111213141516171819202122232425262728293031323334353637383940package hr;import java.util.List;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;public class XPathTestor &#123; public void xpath(String xpathExp) &#123; String file = "d:/Eclipse/workplace/calculator/src/NewFile.xml"; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); List&lt;Node&gt; nodes = document.selectNodes(xpathExp); for( Node node : nodes ) &#123; Element emp = (Element)node; System.out.println(emp.attributeValue("no")); System.out.println(emp.elementText("name")); System.out.println(emp.elementText("age")); System.out.println(emp.elementText("salary")); System.out.println("==========================="); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; XPathTestor testor = new XPathTestor(); // 查询 斜杠/代表根节点// testor.xpath("/hr/employee");// testor.xpath("//employee[@no=3311]");// testor.xpath("//employee[1]");// testor.xpath("//employee[last()]"); testor.xpath("//employee[position()&lt;3]");// testor.xpath("//employee[1] | //employee[2]"); &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 002-两数相加]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%95%B0%E8%AE%BA%2FLeetCode%20002%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[一道很简单的题，但是因为空指针的判别耗了很长时间… 题目 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 代码我的代码(虽然过了但是耗时多)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode now = new ListNode(0); ListNode res = now; while( l1!=null || l2!=null )&#123; boolean flag=false; int sum = 0; if(l1==null)&#123; sum += 0; &#125; else&#123; sum += l1.val; if( l1.next==null ) l1=null; else &#123; l1=l1.next; flag=true; &#125; &#125; if(l2==null)&#123; sum += 0; &#125; else &#123; sum += l2.val; if( l2.next==null) l2=null; else &#123; l2=l2.next; flag=true; &#125; &#125; now.val += sum; if( now.val&lt;10 )&#123; if( flag ) now.next = new ListNode(0); &#125; else&#123; now.next = new ListNode(now.val/10); now.val %= 10; &#125; now = now.next; &#125; return res; &#125;&#125; 官方题解12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 我没想到一个carry用两次，可以放在下一个循环继续用。]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS小记]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FCSS%2FCSS%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[以下是CSS的一些知识及语法。 什么是CSScss指层叠样式表（Cascading Style Sheets)样式通常存储在样式表中css可以统一不同浏览器显示的内容样式 CSS使用目的定义如何显示html元素解决内容（html元素）与表现（浏览器中的呈现）分离的问题 CSS基础语法 CSS声明： 样式属性：background-color 操作符: : 样式值：#FFFFFF 分隔符： ； 声明块：同时使用多个声明语句 1234&#123; background-color:#FFFFFF;color:#000000;&#125; CSS规则：1.选择器：定位页面中的元素2.声明块：由多个CSS声明组成，最外层{}，可以使用多个声明内容 定义CSS的两种方式：内联样式方式、外联样式方式 内联样式方式：&lt;p style=&quot;color:lightcoral;font-weight:bolder;&quot; &gt;&lt;/p&gt;内联方式设置样式只对当前标签有效 外联样式方式：在style内通过元素选择器 设置元素的声明块。此时相当于将CSS嵌入到HTML文件中。123456789101112131415161718&lt;!DOCSTYLE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta lang="en"/&gt;&lt;title&gt;定义CSS的样式&lt;/title&gt;&lt;style&gt;p&#123;color:lightcoral;font-weight:bolder;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p style="font-weight:bolder;color:red;"&gt; 这是内联样式1.&lt;/p&gt;&lt;p style="size:small;color:yellow;"&gt; 这是内联样式2.&lt;/p&gt;&lt;p&gt;这是外联样式&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 注：若进行了内联样式，则其优先级更高。即外联样式声明了元素样式后，若该元素同时进行了内联样式声明，则依照内联样式显示。 CSS选择器： ID选择器（ # +id值） 元素选择器（直接使用元素名称） 类（class）选择器（ . + class名称） 属性选择器（中括号里面写属性名称，如[title]） 后代元素选择器A E : 指定需要修改的元素E与A为祖先和后代关系A&gt;E : 指定需要修改的元素E与A为父元素和子元素关系B+E : 指定需要修改的元素E为B的下一个兄弟元素伪类：主要用于&lt;a&gt;标签。a:link – 链接的样式a:hover – 鼠标悬停时的样式a:active – 点击时的样式a:visited – 访问过后的样式伪元素::before – 为当前元素创建一个排在第一位的子元素。例q::before{ content:”&lt;”;}，会把页面中的引用标签&lt;q&gt;创建伪元素，把默认加的双引号变为&lt;;::after – 为当前元素创建一个排在最后一位的子元素。例q::after {content:”&gt;”;}，会把页面中的引用标签&lt;q&gt;创建伪元素，把默认加的双引号变为&gt;.CSS选择器优先级别1、内联&gt;外联2、内联：id&gt;类选择器&gt;元素/伪类3、在属性后加上：空格+!important让该属性升级为最高级别(会打乱默认的次序，少用) 背景属性background:简写属性，作用是将背景属性设置在一个声明中background-color：设置元素的背景颜色background-image:把图像设置为背景（通过url定位文件中的图片路径，将图片设置为背景）background-position：设置背景图像的起始位置background-repeat:设置背景图像是否及如何重复因为p元素作为一个块级元素出现，它默认占到页面的整个宽度，即使文本内容很少，但它依旧会占到页面的整个宽度，所以背景图片会重复显示以填充所有区域内容background-repeat:设置背景图像是否及如何重复repeat:表示水平和垂直方向都是重复显示的no-repeat:表示水平和垂直方向都是不重复显示的 Tips： 无文本信息仅插入图片时，无法正常显示图片。这是由于未显示文本，导致分配的大小为：0，无法正常显示。此时需要手动设置 高height和宽width； 需要显示部分图片时，可以通过更改 高height和宽width来调节显示图片的大小。高和宽的数值正负代表图片的移动方向，即：需要显示图片中某一块时，高和宽都是负值。 CSS文本样式color：设置字体颜色text-align：文本水平对齐text-decoration：向文本添加修饰text-indent：文本首行缩进vertical-align：文本垂直对齐 关于文本水平、垂直居中： 字体font-family 指定文本的字体系列font-size 指定文本的字体大小font-style 指定文本的字体样式font-weight 指定字体的粗细 列表与表格列表list-style 用于把所有用于列表的属性设置于一个声明中list-style-image 把图像设置为列表项标志list-style -type 设置列表项标志的类型 表格border 设置表格边框border-collapse 设置边框是否被折叠成单个或隔开width 定义表格的宽度text-align 表格中文本对齐padding 设置表格的填充(内边距) CSS盒子模型 内边距paddingpadding： 使用缩写属性设置在一个声明中的所有填充属性padding-bottom: 设置元素的底部填充padding-left： 设置元素的左部填充padding-right： 设置元素的右部填充padding-top: 设置元素的顶部填充注：padding：全部padding:上下 左右padding：上 左右 下padding：上 右 下 左 外边距margin类似。 边框 border:10px black solid;三个属性意思是：边框宽度 颜色 实/虚线 Tips：1.内外边距和边框的使用会使当前盒子变大2.内边距享有当前盒子背景色 CSS定位机制普通流(标准流):默认状态,从左往右, 从上到下排列块元素： 独占一行 可以设置宽、高 如果不设置宽度，宽度默认为容器的100% div、p、h1-h6、ul、ol、li、dl、dt、dd(定义列表) 行内元素 与其他元素同行显示 不可以设置宽、高 宽高就是文字或图片的宽高 span、a、b、i、u、em…… 浮动 只能使元素向左或向右移动, 不能上下移动 浮动元素碰到包含框 或另一个浮动框, 浮动停止 浮动元素之后的元素将围绕它, 之前的不受影响 浮动会脱离标准流浮动的基础语法float:leftfloat:rightfloat:nonefloat:inherit 继承父类的浮动效果 浮动的理解浮动可以实现块级元素在一行中横向排列。浮动的原理是：当前的块从当前的容器里面脱离出来，虽然浮动后脱离了文档流（容器）但是文本流还在，还是会占据文本空间（这里带来的问题是：原来下一个块的内容可能会被浮动的内容占满 使该块本身的内容溢出）清除浮动是把浮动元素回归文档流, 撑起重启高度。 清除浮动语法clear:none | left | right |both;none: 不清除浮动left: 清除该元素左边的浮动right: 清除该元素右边的浮动both: 清除所有浮动inherit: 继承父类清除浮动的值 清除浮动常用的方法 方法一：在浮动元素后使用一个空元素。例如：&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 方法二：给浮动元素的容器添加overflow：hidden;可同时添加 *zoom:1 /*触发hasLayout 兼容IE6、7*/ 方法三：使用CSS3的:after伪元素 12345678.clearfix:after&#123;content: ".";display: block;height: 0;visibility: hidden;clear: both;&#125;.clearfix&#123;*zoom:1; /*触发hasLayout 兼容IE6、7*/&#125; 方法四：通过父级元素清除浮动 (较少使用) 父级元素定义height。只适用于高度固定的布局。 父级元素也一起浮动。不推荐, 会产生新的浮动问题。 CSS定位position:既是一个定位布局模块（提供与元素定位和层叠相关功能，是一个核心模块，又是一个属性模块内包含： 盒子模型的类型和尺寸 布局模型 元素之间的关系 视口大小、图像大小等其他相关方面 重要的定位模型：static ：静态模型/自然模型relative：相对定位模型absolute：绝对定位模型fixed：固定定位模型sticky：磁铁定位模型 static：作用：使元素定位于 常规/自然流 中特点： 忽略 top/bottom/left/right 或者z-inherit声明 两个相邻的元素如果都设置外边距，最终外边距=两者外边距中最大的那个 具有固定width和height值的元素，若把左右外边距设置为auto，则左右外边距会自动扩大占满剩余宽度。造成水平居中效果。 relative：作用: 使元素成为可定位的祖先元素特点： 可以使用top/right/bottom/left/z-index相对于该元素的原位置进行偏移 相对定位的元素，原来在标准流中的位置依旧保留，后面元素接在元素原位置之后 任何元素都可设置relative, 它绝对定位的后代都可以相对它进行绝对定位 可以使的浮动元素发生偏移，并控制它们的堆叠顺序 absolute：作用：使元素脱离常规流特点： 脱离常规流 设置尺寸要注意：百分比比的是最近定位祖先元素 若没有最近定位祖先元素，会以&lt;body&gt;为祖先元素 left/right/top/bottom若设置为0，它将对齐到最近定位祖先元素的各边，居中效果。 若left/right/top/bottom设置为auto，它将会回归到常规流 fixed ：作用: 同absolute相同，使元素脱离常规流特点： fixed相对于视口(用户当前可见界面)做绝对定位 固定定位元素不会随着视口滚动而滚动 继承absolute特点 （left/right/top/bottom若设置为0，它将对齐到最近定位祖先元素的各边，居中效果。 若left/right/top/bottom设置为auto，它将会回归到常规流） sticky磁铁定位/粘性定位/吸附定位作用：relavtive+fixed的完美结合，制造出吸附效果特点： 如果产生偏移原位置还是会在常规流中，一亩三分地留着。 如果它的最近祖元素有滚动，那么它的偏移标尺就是最近祖先元素 如果最近祖先元素没有滚动 那么它的偏移标尺是视口。 上下左右的偏移规则 总结盒子模型: 通过改变元素的margin和padding来控制元素的移动。定位: 通过元素的位置移动改变出现在网页的相对位置。先通过定位调整元素的大体位置, 再用盒子模型调整元素最后的位置]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML小记]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FHTML%2FHTML%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[由于要学习Java Web开发，先学习一下HTML。下面是一些基础知识。 标题标签标题标签共有六级：&lt;h1,2,3,4,5,6&gt;&lt;/……&gt;如：1&lt;h1&gt;一级标题&lt;/h1&gt; 对应大小：h1,2,3,4,5,6–32px,24px,18px,16px,14px,12px1em=16px 段落1&lt;p&gt;段落内容&lt;/p&gt; 默认浏览器样式，空标签也会占位置（本来是空的，但由于浏览器可能默认设置为固定大小，因此需要自定义）； 标签的默认浏览器可能造成部分问题，建议自定义； 设置段落标签的属性:在head内的style中设置123456&lt;style&gt;p&#123; margin: 0; padding: 0;&#125;&lt;/style&gt; 如此，内外边距为0。 字体基本不用，一般在css中设置。1&lt;font&gt;字体内容&lt;/font&gt; size: 字体大小face：字体集color：颜色，三种表示法——名称，16进制，rgb坐标 链接123&lt;a&gt;HTML链接&lt;/a&gt;&lt;a href="http://www.makersy.top" target="_blank"&gt;博客&lt;/a&gt; (新建一个窗口)&lt;a href="http://www.makersy.top" target="_self"&gt;博客&lt;/a&gt; （在当前页面打开） 页面锚点123&lt;a href="#xxx"&gt;页面内锚点&lt;/a&gt;（跳转到id为xxx的地方）&lt;h3 id="xxx"&gt; 你好&lt;/h3&gt; 禁止跳转1&lt;a href="javascript:; / javascript:void(0);"&gt;死链接&lt;/a&gt; ---这是一个死链接 去掉下划线、去掉指向链接时光标的手形1234a&#123;text-decoration: none;cursor: none;&#125; 列表 无序列表 1&lt;ul&gt;&lt;li&gt;内容&lt;/li&gt;&lt;/ul&gt; 有序列表 1&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 定义列表 1234&lt;dl&gt; &lt;dt&gt;定义概念的名字&lt;/dt&gt; &lt;dd&gt;概念的解释 主体&lt;/dd&gt;&lt;/dl&gt; 贴士： type属性项目符号样式&lt;ul type=&quot;&quot;&gt;&lt;/ul&gt;（disc（实心圆）,circle（空心圆）,square(实心方形)，none表示不去设置它的项目符号样式，但会保留项目符号所在的位置）不建议使用！有序标签ol无法设置项目符号，独具特色的顺序就是他的项目符号定义列表也无法设置其项目符号 只用&lt;ul&gt;&lt;/ul&gt;无序列表就好了以后看到样式，都不要通过html（或者元素本身属性）去设置，通过css。 图像 标签 作用 插入图像 属性 src（src这个属性是图片的地址，有这个属性才能实现图像效果。） 支持格式： PNG、JPEG、GIF、PDF（引入的PDF必须是单页的） 非标签方式：background alt：在图片无法显示比如地址写错时，提示用户这里本来放的是什么 class:标识，用来指定标签的类名例：12345678910&lt;img alt="logo" src="https://img1.mukewang.com/5b8cef4200019d9a02000200-140-140.jpg"&gt;&lt;!-- 非标签方式 --&gt;&lt;style&gt;.logo&#123;background: url(https://img1.mukewang.com/5b8cef4200019d9a02000200-140-140.jpg);width: 140px;height: 150px;&#125;&lt;/style&gt;&lt;p class="logo"&gt;&lt;/p&gt; 插入本地图像路径：绝对路径– C:\html\logo.jpg，相对路径– 与文件同级目录下– ./img/logo.png 或者 ../logo.png div&lt;div&gt;&lt;/div&gt; 万能标签 无语义标签作用：布局贴士：非常常用且重要 现代布局常用 块级元素与行内元素块级元素垂直分段排列。行内元素水平一行内一个挨着一个。&lt;span&gt;包裹一行内容&lt;/span&gt;块级元素大小取决于开发者的设置，行内元素大小取决于内容 注释单行注释：&lt;!--注释文本--&gt;多行注释：&lt;!--注释开始--&gt;...&lt;!--注释结束--&gt;，这里，多行注释不会隐藏注释间的内容，只是开发时的提示。条件注释：&lt;!--[if IE 6]&gt;注释内容&lt;![endif]--&gt;，这里，条件注释主要用于浏览器兼容性。条件注释只在IE10以下版本的浏览器中生效。提示浏览器较旧。 一些不常用的标签以下标签一般都不用！！！文本格式化标签（为避免浏览器差异，一般不用，多用css设置） 12345678&lt;b&gt;加粗&lt;/b&gt;&lt;strong&gt;加粗2&lt;/strong&gt;&lt;big&gt;大号字体&lt;/big&gt;&lt;em&gt;强调字体(斜体)&lt;/em&gt;&lt;i&gt;斜体/图标&lt;/i&gt;&lt;small&gt;小号字体&lt;/small&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;sup&gt;上标&lt;/sup&gt; 预格式文本标签：&lt;pre&gt;一般这里是预览的代码&lt;/pre&gt;引用标签：&lt;blockquote&gt;引用来的&lt;/blockquote&gt;删除线标签：&lt;del&gt;删除的内容&lt;/del&gt;下划线标签:&lt;ins&gt;下划线的内容&lt;/ins&gt; 表格12345678910111213141516&lt;!-- 无序列表 --&gt;野生动物&lt;ul type="circle"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;栗子&lt;/li&gt;&lt;/ul&gt;&lt;!-- 有序列表 --&gt;&lt;ol&gt; &lt;li&gt;煎饼果子&lt;/li&gt; &lt;li&gt;台湾饭团&lt;/li&gt;&lt;/ol&gt;&lt;!-- 定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;正数&lt;/dt&gt; &lt;dd&gt;大于0的自然数&lt;/dd&gt;&lt;/dl&gt; 表单标签&lt;form&gt; &lt;/form&gt;作用：手机用户输入的内容（文本、文件）属性：（1）action：提交到的服务端地址（2）method：指定提交时用哪种HTTP方法：POST/GET（3）name:标识（4）autocomplete:浏览器是否可以填充（5）enctype:指定表单内容编码input:文本、密码、单选、多选、按钮、数字、日期、颜色、范围、邮件、URL、文件select:下拉列表textarea:文本域button:按钮inout(单尖括号标签)文本：&lt;input type=&quot;text&quot;maxlength=&quot;&quot;(最大输入框长度)value=&quot;&quot;/&gt;密码：&lt;input type=&quot;password&quot;value=&quot;&quot;/&gt;单选：&lt;input type=&quot;radio&quot; name=&quot;&quot;vaule=&quot;&quot;/&gt;做单选操作，name要相同多选:&lt;input type=&quot;checkbox&quot;name=&quot;&quot;value=&quot;checked&quot;/&gt;(checked)默认选中按钮：&lt;input type=&quot;button&quot;value=&quot;&quot;/&gt;数字:&lt;input type=&quot;number&quot;/&gt;日期：&lt;input type=&quot;date&quot;/&gt;颜色：&lt;input type=&quot;color&quot;/&gt;(由于兼容性问题不是很常用)范围:&lt;input type=&quot;range&quot;min=&quot;&quot; max=&quot;&quot;/&gt;邮件:&lt;input type=&quot;email&quot;/&gt;提交按钮:&lt;input type=&quot;submit&quot;value=&quot;提交&quot;/&gt;URL:&lt;input type=&quot;url&quot;/&gt;(和邮件一样自带格式校验)文件：&lt;input type=&quot;file&quot;mulitple=&quot;multiple&quot;(多个文件)&gt;select：下拉列表如果&lt;select&gt;标签中设置了multiple或size属性的话,那么select就是列表了，不是下拉菜单；不设置是下拉菜单，所以代码实现了一个列表。multiple多选，size显示可见选项数目。12345678910111213&lt;select name="" id=""&gt;&lt;option value="" selected(设置默认值)&gt; &lt;/option&gt;&lt;option value="" &gt; &lt;/option&gt;&lt;option value="" &gt; &lt;/option&gt;&lt;/select&gt;textarea：文本域&lt;style&gt;textarea&#123;resize:none;(使其没有可拖拽能力）&#125;&lt;textarea rows=""(决定有几行高) cols=""(决定有多宽）&gt; 。。。。。（默认值） &lt;/textarea&gt;button：按钮&lt;button type=""(可以指明三个值 1、button 普通按钮 2、submit 带提交行为 3、reset 重置） form="(此处应该是表单的name) "&gt;提交（设置名字）&lt;/button&gt; 总结]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫笔记]]></title>
    <url>%2Fpython%2F%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[python爬虫笔记 判断请求是否成功1assert response.status_code==200 字符串格式化的一种方式1"你&#123;&#125;好".format(1) 使用代理ip 准备一堆ip地址，组成ip池，随机选择一个ip来使用 如何随机选择代理ip {“ip”:ip,”times”:0} [{},{},{},{},{}],对这个ip的列表进行排序，按照使用次数进行排序 选择使用次数较少的10个ip，从中随机选择一个 检查ip的可用性 可以使用requests添加超时参数，判断ip地址的质量 在线代理ip质量检测网站 携带cookie请求 尽量不使用cookie 携带一堆cookie进行请求，把cookie组成cookie池 请求登陆之后的网站的思路 实例化session 先使用session发送请求，登陆对网站，把cookie保存在session中 再使用session请求登录之后才能访问的网站，sesssion能够自动携带登陆成功时保存在其中的cookie，进行请求 不发送post请求，使用cookie获取登陆后的页面 cookie过期时间很长的网站 在cookie过期之前能够拿到所有的数据，比较麻烦 配合其他程序一起使用，其他程序专门其获取cookie，当前程序专门请求页面 字典推导式，列表推导式12cookies = "uuid_tt_dd=10_18697420810-1541514998525-406120; dc_session_id=10_1541514998525.130001; c_adb=1; smidV2=2018110622540004c9a404e4b4418224a1bc1f0afbaf24004db7a451c1dc9c0; UN=makersy; TY_SESSION_ID=bcb2fab5-1594-432f-b08b-77ff1c25478c; SESSION=04780891-f506-4bae-9eb9-7bee9b0f01b6; UserName=makersy; UserInfo=TY72nyXcSQ4kxcpYdP3noqwQsV904wqUfUrjssi1EYiqf77of1nXIX31igaPjkMfWt%2FBg37Ty5yCAFxluyxuwvK%2BjTb8WKRG2o8PpCGW7eCE5ImRX5bUUNkAvcYMhTjY; UserNick=makersy; AU=7FA; BT=1541516799322; UserToken=TY72nyXcSQ4kxcpYdP3noqwQsV904wqUfUrjssi1EYiqf77of1nXIX31igaPjkMfWt%2FBg37Ty5yCAFxluyxuwvK%2BjTb8WKRG2o8PpCGW7eAvjKefqLie1zAAltRYdzP1Sk%2Bfm7yuJ%2FP%2Fbsd6wSQVGMnSmTWc8bbv2HgJOkqFDhc%3D; ARK_ID=JSc5d36a4d0c44c361b2667ed6147b5607c5d3; dc_tos=phs2bi"cookies = &#123;i.split("=")[0]:i.split("=")[1] for i in cookies.split("; ")&#125; 获取登陆后的页面的三种方式 实例化session，使用session发送post请求，在使用他获取登陆后的页面 headers中添加cookie键，值为cookie字符串 在请求方法中添加cookie参数，接受字典形式的cookie，字典形式的cookie中的键是cookie的name对应的值，值是cookie的value对应的值]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java连接高版本mysql数据库(8.0)的坑]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2Fjava%E8%BF%9E%E6%8E%A5%E9%AB%98%E7%89%88%E6%9C%ACmysql%E6%95%B0%E6%8D%AE%E5%BA%93-8-0-%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[今天在写java连接mysql数据库时，遇到了无法连接的问题。报错信息如下: Loading class ‘com.mysql.jdbc.Driver’. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. Sat Sep 22 16:28:36 GMT+08:00 2018 WARN: Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. java.sql.SQLException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 这三段意思是说： 驱动不再是之前的com.mysql.jdbc.Driver而是’com.mysql.cj.jdbc.Driver’； mysql8.0不需要使用ssl连接，因此需要设置手动设置useSSL=false； mysql返回的时间与实际不一样，需要设置在jdbc连接的url后面加上serverTimezone=GMT(即时区)。 因此应该这么写：1234 Class.forName("com.mysql.cj.jdbc.Driver");// Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost/EXAMPLE?useSSL=false&amp;serverTimezone=GMT","root","password");// conn = DriverManager.getConnection("jdbc:mysql://localhost/EXAMPLE","root","password"); 注释里是之前的写法。]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String&StringBuffer]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2FString-StringBuffer%2F</url>
    <content type="text"><![CDATA[String介绍 String是Java中很常见的类，是一个final修饰的不可变的数组，用来存放字符的容器。不可变是什么意思呢，意思是被赋值后就不能被改变了，如果再进行修改的话实质上是创建一个新对象，并将引用指向新对象，原来的对象被当做垃圾回收掉了。这是效率很低的。 用法1.求字符串某一位置字符 1char charAt(int index)//返回字符串中指定位置的字符；注意字符串中第一个字符索引是0，最后一个是length()-1。 1String str = new String("asdfzxc"); 2获取角标 1Int indexOf(char c) 例如： 1String s=”Java”; Int a=s.indexOf(a); 3判断 字符串是否包含某个字符串 1boolean contains(str)//判断源字符串是否包含str字符串并返回boolean值 例如：String str=”My love Java”; Boolean b=str.contains(love); 结果：true 字符串是否有内容 1boolean isEmpty() 例如：booleanb=str.isEmpty(); 字符串是否以指定内容开始 1boolean startsWith(str) 例如：booleanb=str.startsWith(“My”); 字符串是否以指定内容结束 1boolean endsWith(str); 用法如上 判断内容是否相同 1boolean equals(str) //String类重写了Object类中的equals方法，该方法用于判断字符串内容是否相同而非判断地址 例如: 12345String str1=”Java”;String str2=”love”;boolean s=str1.equals(str2); 判断内容是否相同，并忽略大小写 1Boolean equalsIngoreCase(str) 用法同上 4提取子串用String类的substring方法可以提取字符串中的子串，该方法有两种常用参数: public String substring(int beginIndex) //该方法从beginIndex位置起，从当前字符串中取出剩余的字符作为一个新的字符串返回。 public String substring(int beginIndex, int endIndex) //该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回 1231 String str1 = new String("asdfzxc");2 String str2 = str1.substring(2);//str2 = "dfzxc"3 String str3 = str1.substring(2,5);//str3 = "dfz" 5字符串比较 public int compareTo(StringanotherString) //该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。 public int compareToIgnore(StringanotherString) //与compareTo方法相似，但忽略大小写。 public boolean equals(ObjectanotherObject) //比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。 6字符串中字符的大小写转换 public String toLowerCase() //返回将当前字符串中所有字符转换成小写后的新串 public String toUpperCase() //返回将当前字符串中所有字符转换成大写后的新串 1231 String str = new String("asDF");2 String str1 = str.toLowerCase();//str1 = "asdf"3 String str2 = str.toUpperCase();//str2 = "ASDF" 7字符串中字符的替换 public String replace(char oldChar, charnewChar) //用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。 public String replaceFirst(String regex,String replacement) //该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。 public String replaceAll(String regex,String replacement) //该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。 1234567891 String str = "asdzxcasd";2 String str1 = str.replace('a','g');//str1 = "gsdzxcgsd"3 String str2 = str.replace("asd","fgh");//str2 = "fghzxcfgh"4 String str3 = str.replaceFirst("asd","fgh");//str3 = "fghzxcasd"5 String str4 = str.replaceAll("asd","fgh");//str4 = "fghzxcfgh"字符串分隔String[] split(String str)//将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。1 String str = "asd!qwe|zxc#";2 String[] str1 = str.split("!|#");//str1[0] = "asd";str1[1] = "qwe";str1[2] = "zxc"; 8字符串与基本类型的转换 字符串转换为基本类型java.lang包中有Byte、Short、Integer、Float、Double类的调用方法: public static byte parseByte(String s) public static short parseShort(String s) public static short parseInt(String s) public static long parseLong(String s) public static float parseFloat(String s) public static double parseDouble(String s) 字符串基本类型时，如int short dobule字符串中的数据一定要是数字，否则会出现异常。 例如： 1231 int n = Integer.parseInt("12");2 float f = Float.parseFloat("12.34");3 double d = Double.parseDouble("1.124"); 9基本类型转换为字符串类型 String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。 static String valueOf(char data[]) static String valueOf(char data[], intoffset, int count) static String valueOf(boolean b) static String valueOf(char c) static String valueOf(int i) static String valueOf(long l) static String valueOf(float f) static String valueOf(double d) 例如： 121 String s1 = String.valueOf(12);2 String s1 = String.valueOf(12.34); 10和数组有关的方法 返回类型 方法名 作用 byte[] getBytes() 将一个字符串转换成字节数组 String[] split(String) 将一个字符串按照指定内容劈开 char[] toCharArray() 将一个字符串转换成字符数组 11判断是否为空 public boolean isEmpty() 当且仅当 length()为 0 时返回 true。 String Buffer常用方法 public StringBuffer append(boolean b) 该方法的作用是追加内容到当前StringBuffer对象的末尾，类似于字符串的连接。调用该方法以后，StringBuffer对象的内容也发生改变， public StringBuffer deleteCharAt(int index) 该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。 public StringBuffer deleteCharAt(int index) 该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。 public StringBuffer insert(int offset, boolean b) 该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串。 public StringBuffer reverse() 该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串。 public void setCharAt(int index, char ch) 该方法的作用是修改对象中索引值为index位置的字符为新的字符ch。]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java大数基本用法]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2FJava%E5%A4%A7%E6%95%B0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近学Java有接触到大数运算，感觉比用c++自己写个算法方便太多，在此记录下代码。java中用于操作大数的类主要有两个，一个是BigInteger，代表大整数类，用于对大整数进行操作；另一个是BigDecimal，代表高精度类，用于对比较大或精度比较高的浮点型数据进行操作。两个比较像。 基本用法1、新建一个值为123的大整数对象12BigInteger a=new BigInteger(“123”); //第一种，参数是字符串 BigInteger a=BigInteger.valueOf(123); //第二种，参数可以是int、long 2、大整数的四则运算1234a. add(b); //a,b均为BigInteger类型，加法 a.subtract(b); //减 法 a.divide(b); //除法 a.multiply(b); //乘法 3、大整数比较大小12a.equals(b); //如果a、b相等返回true否则返回false a.compareTo(b); //a小于b返回-1，等于返回0，大于返回1 4、常用方法1234a.mod(b); //求余 a.gcd(b); //求最大公约数 a.max(b); //求最大值 a.min(b); //求最小值 例子HDU1002 a+b 12345678910111213141516171819import java.util.*;import java.math.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int t = sc.nextInt(); BigInteger a, b, c; for( int i=1; i&lt;=t; i++ ) &#123; System.out.println("Case " + i + ":"); a = sc.nextBigInteger(); b = sc.nextBigInteger(); System.out.println(a + " + " + b + " = " + a.add(b)); if( i!=t ) &#123; System.out.println(); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018CCPC-网络赛 1001 Buy and Resell]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E8%B4%AA%E5%BF%83%2F(HDU)2018CCPC-%E7%BD%91%E7%BB%9C%E8%B5%9B%201001%20Buy%20and%20Resell%2F</url>
    <content type="text"><![CDATA[Buy and Resell Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 2282 Accepted Submission(s): 359 Problem Description The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day: spend ai dollars to buy a Power Cube resell a Power Cube and get ai dollars if he has at least one Power Cube do nothing Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning. Input There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case:The first line has an integer n. (1≤n≤105)The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109)It is guaranteed that the sum of all n is no more than 5×105. Output For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit. Sample Input 341 2 10 959 5 9 10 522 1 Sample Output 16 45 20 0 题意有n个位置，每个位置有一个价格a[i]，按从1-n顺序经过每个位置，每个位置都可以进行三种操作之一且只能进行一次：1) 花a[i]元购买一个物品；2）卖掉一个手上的物品得到a[i]元； 3）什么也不做。假设金钱无限，初始没物品，身上可以装无限个物品，求走完所有城市后所能得到的最大利润和得到该最大利润所需的最少操作数。 题解低买高卖，此题可应用贪心的思想，每次遇到一个价格时，总是与前面的最低价进行“抵消”，这样利润最大。但是也许后面还有比这个价格更高的，所以需要“反悔”的机会，把错误时机卖出的损失挽回。因此优先队列（价格低标记值大先出队）代表已有物品，每到一个城市，先判断此地价格是不是比队列的最低价格高，是的话就可以将最低价格的物品卖掉了，再把差值加到利润上。然后最低价弹出，在队列里插入此地价格两个，分别以1和0标记（已经卖过一次，尚未卖过）。如此循环，假如后面有更高价想反悔，就把标记为1的错误卖出值弹出，队中标记为0的代表这个值现在是未被使用，可参与买卖。举个例子：样例中有“1 2 10 9”这个情况，首先花1元买物品，遇到2时我会把1给卖出，队里插入“2 1”“2 0”，利润为-1+2=1。后来又遇到10，2就属于贱卖当然不行，此时队里有两个2，让标记为1的出队，剩下的2的标记为0，代表没有被使用过，插入“10 1”“10 0”，此时利润值为1-2+10=9（跟1买10卖的利润是一样的）。下一个遇到9，此时队中最小为2，消之，利润计算为9-2+9=16。至于操作次数计算就简单了，只需要每次在标记为0的价格出队时总次数+2即可。以下为代码：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;struct node&#123; int v, s; //v--价格，s--状态 node(int a, int b):v(a), s(b)&#123;&#125; //重载&lt;运算符，使优先队列让v小的先出队，v相同则s大的先出队 //优先队列默认把结构体按从大到小排序，重载&lt;运算符使其按照自定义顺序排序 bool operator&lt;(const node &amp;a) const&#123; if( v==a.v ) return s&lt;a.s; return v&gt;a.v; &#125;&#125;;int main() &#123; int t; while( t-- )&#123; int n; LL profit=0, cnt=0; scanf("%d", &amp;n); priority_queue&lt;node&gt; que; for( int i=0; i&lt;n; i++ )&#123; int c; scanf("%d", &amp;c); if( !que.empty() &amp;&amp; que.top().v&lt;c )&#123; node tmp=que.top(); profit=profit-tmp.v+c; if( tmp.s==0 ) cnt+=2; //当前最小值之前没有买过，次数加2(以最小值买，以最大值卖) que.pop(); que.push(node(c, 1)); que.push(node(c, 0)); &#125; else&#123; que.push(node(c, 0)); &#125; &#125; printf("%lld %lld\n", profit, cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C/C++</tag>
        <tag>队列</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(HDU)2018CCPC - 网络赛 1004 Find Integer]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%95%B0%E8%AE%BA%2F(HDU)2018CCPC-%E7%BD%91%E7%BB%9C%E8%B5%9B%201004%20Find%20Integer%2F</url>
    <content type="text"><![CDATA[Find Integer Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Special Judge Problem Description people in USSS love math very much, and there is a famous math problem .give you two integers n,a,you are required to find 2 integers b,c such that an+bn=cn. Input one line contains one integer T;(1≤T≤1000000)next T lines contains two integers n,a;(0≤n≤1000,000,000,3≤a≤40000) Output print two integers b,c if b,c exits;(1≤b,c≤1000,000,000);else print two integers -1 -1 instead. Sample Input 1 2 3 Sample Output 4 5 题解本题给出一个费马大定理的表达式 —— $a^n+b^n=c^n,(a,b,c) \in Z$。 题目意思是给定该公式中的a和n，求满足公式的b和c并输出，若不存在满足公式的b和c，则输出”-1 -1”。所以当n&gt;2或n==0时输出”-1 -1”；当n=1时输出满足方程的第一组解：1 a+1；当n=2时输出勾股数。求勾股数：这种前n项固定的情况一般可以采用打表法。三层循环肯定是不行的，这么大数据量肯定tle。$a^2=c^2-b^2=(c+b)(c-b)$。令$x=c+b,y=c-b$，于是$a^2=xy$。从x着手，当满足a2可以整除x时就可以求出符合条件的b，c。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longstruct node&#123; ll b,c;&#125;gg[40007];void init()&#123; memset(gg, 0, sizeof(gg)); for( ll i=3; i&lt;=40000; i++ )&#123; for( ll j=1; j&lt;i; j++ )&#123; if( i*i%j==0 )&#123; //若a^2可以整除(c+b),则此式成立 ll x = j; ll y = i*i/j; if( (y-x)%2==0 )&#123; //若b为整数,则c也是整数 gg[i].c=(x+y)/2; gg[i].b=(y-x)/2; break; &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); int t; scanf("%d", &amp;t); while( t-- )&#123; ll a, n; scanf("%lld%lld", &amp;n, &amp;a); if( n&gt;2 || n==0 )&#123; printf("-1 -1\n"); continue; &#125; else if( n==1 )&#123; printf("1 %lld\n", a+1); continue; &#125; else&#123; if( gg[a].b )&#123; printf("%lld %lld\n", gg[a].b, gg[a].c); &#125; else printf("-1 -1\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C/C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT L2-019. 悄悄关注]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FSTL%2FPAT%20L2-019%20%E6%82%84%E6%82%84%E5%85%B3%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[一道水题 题目 新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。 输入格式： 输入首先在第一行给出某用户的关注列表，格式如下： 人数N 用户1 用户2 …… 用户N 其中N是不超过5000的正整数，每个“用户i”（i=1, …, N）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。 之后给出该用户点赞的信息：首先给出一个不超过10000的正整数M，随后M行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。 输出格式： 我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。 输入样例1： 10 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao8Magi 50Pota 30LLao 3Ammy 48Dave 15GAO3 31Zoro 1Cath 60 输出样例1： AmmyCathPota 输入样例2： 11 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao Pota7Magi 50Pota 30LLao 48Ammy 3Dave 15GAO3 31Zoro 29 输出样例2： Bing Mei You 题目比较简单，就是找出点赞数大于均值且名字不在关注列表里的人，排个序就好了。总结下： 用set存储元素时自动升序排序。set存储字符串用string； 存储数组一般开大些，’\0’会占位。如存储4个字母数组不能只开char[4]。 以下为代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;typedef struct &#123; char name[10]; int num;&#125;zan; //点赞信息zan a[10010];int main()&#123; set&lt;string&gt; men; //存储关注列表 set&lt;string&gt; se; //存储悄悄关注的人 set&lt;string&gt;::iterator it; int n; cin &gt;&gt;n; for( int i=0; i&lt;n; i++ )&#123; string s; cin &gt;&gt;s; men.insert(s); &#125; int m; double sum = 0; cin &gt;&gt;m; for( int i=0; i&lt;m; i++ )&#123; cin &gt;&gt;a[i].name &gt;&gt;a[i].num; sum += a[i].num; &#125; sum /= (m*1.0);//寻找符合条件的人 for( int i=0; i&lt;m; i++ )&#123; if( a[i].num &gt; sum )&#123; if( men.count(a[i].name) == 0 )&#123; se.insert(a[i].name); &#125; &#125; &#125; //结果列表空则输出没有，有则遍历输出 if( se.size() == 0 )&#123; printf("Bing Mei You\n"); &#125; else&#123; for( it=se.begin(); it!=se.end(); it++ )&#123; cout &lt;&lt;*it &lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2Funcategorized%2Fhello%2F</url>
    <content type="text"><![CDATA[Hello 嗯…花费了大概一天的时间才搭好这个基于Github+Hexo的博客，对于啥经验都没有的我来说，已经很满足了。参考了不少网上大佬的教程，遇到了很多百度也没有解答的问题(比如git bash不识别nodejs…)，但在完成后看到首页的瞬间还是很有成就感的。为什么要建博客呢，原因无外乎那几种，但最主要的还是想有个属于自己的地方，存放一些文章，记录学习、生活的历程，起个日记本的作用。 那么，就从今天开始吧。]]></content>
  </entry>
</search>
