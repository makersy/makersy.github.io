<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Java】集合-LinkedList详解]]></title>
    <url>%2FJava%2F%E9%9B%86%E5%90%88%2F%E3%80%90Java%E3%80%91%E9%9B%86%E5%90%88-LinkedList%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言本篇主要记录Java集合类中LinkedList的用法、结构以及部分实现。 LinkedList简介LinkedList是一个实现了List接口和Deque接口的双端链表。 它实现了的其他接口还有Cloneable, java.io.Serializable，另外他也继承了AbstractSequentialList抽象类。LinkedList底层的链表结构使它支持高效的插入和删除操作，实现了Deque接口，使得LinkedList类也具有队列的特性;LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：1List list=Collections.synchronizedList(new LinkedList(...));### 内部结构分析LinkedList的内部结构如下图所示：Node就是链表中的节点。那么LinkedList类中的一个内部静态私有类Node就很好理解了：1234567891011private static class Node&lt;E&gt; &#123; E item;//节点值 Node&lt;E&gt; next;//后继节点 Node&lt;E&gt; prev;//前驱节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。### LinkedList源码分析#### 构造方法空构造方法：12public LinkedList() &#123;&#125;用已有的集合创建链表的构造方法：1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125;#### add方法add(E e) 方法：将元素添加到链表尾部1234public boolean add(E e) &#123; linkLast(e);//这里就只调用了这一个方法 return true;&#125;1234567891011121314/** * 链接。使得 e 作为最后一个元素。 */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode;//新建节点 if (l == null) first = newNode; else l.next = newNode;//指向后继元素也就是指向下一个元素 size++; modCount++;&#125;add(int index,E e)：在指定位置添加元素12345678public void add(int index, E element) &#123; checkPositionIndex(index); //检查索引是否处于[0-size]之间 if (index == size)//添加在链表尾部 linkLast(element); else//添加在链表中间 linkBefore(element, node(index));&#125;linkBefore方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index对应的node addAll(Collection c )：将集合插入到链表尾部 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125; addAll(int index, Collection c)： 将集合从指定位置开始插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //1:检查index范围是否在size之内 checkPositionIndex(index); //2:toArray()方法把集合的数据存到对象数组中 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; //3：得到插入位置的前驱节点和后继节点 Node&lt;E&gt; pred, succ; //如果插入位置为尾部，前驱节点为last，后继节点为null if (index == size) &#123; succ = null; pred = last; &#125; //否则，调用node()方法得到后继节点，再得到前驱节点 else &#123; succ = node(index); pred = succ.prev; &#125; // 4：遍历数据将数据插入 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; //创建新节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //如果插入位置在链表头部 if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; //如果插入位置在尾部，重置last节点 if (succ == null) &#123; last = pred; &#125; //否则，将插入的链表与先前链表连接起来 else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; 上面可以看出addAll方法通常包括下面四个步骤： 检查index范围是否在size之内 toArray()方法把集合的数据存到对象数组中 得到插入位置的前驱和后继节点 遍历数据，将数据插入到指定位置 addFirst(E e)： 将元素添加到链表头部 123public void addFirst(E e) &#123; linkFirst(e);&#125; 12345678910111213private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//新建节点，以头节点为后继节点 first = newNode; //如果链表为空，last节点也指向该节点 if (f == null) last = newNode; //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素 else f.prev = newNode; size++; modCount++;&#125; addLast(E e)： 将元素添加到链表尾部，与 add(E e) 方法一样 123public void addLast(E e) &#123; linkLast(e);&#125; 根据位置取数据的方法get(int index)： 根据指定索引返回数据 123456public E get(int index) &#123; //检查index范围是否在size之内 checkElementIndex(index); //调用Node(index)去找到index对应的node然后返回它的值 return node(index).item;&#125; 12345678910111213141516Node&lt;E&gt; node(int index) &#123; // 获取某位置的Node节点 // 判断索引值是在链表前半部分还是后半部分，前半部分从头遍历 // 后半部分从尾遍历 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 获取头节点（index=0）数据方法: 123456789101112131415161718public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;public E element() &#123; return getFirst();&#125;public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125; 区别：getFirst()，element()，peek()，peekFirst()这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中getFirst() 和element() 方法将会在链表为空时，抛出异常。 element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException异常。 获取尾节点（index=-1）数据方法: 12345678910 public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125;public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;&#125; 两者区别：getLast() 方法在链表为空时，会抛出NoSuchElementException，而peekLast() 则不会，只是会返回 null。 根据对象得到索引的方法int indexOf(Object o)： 从头遍历找 12345678910111213141516171819public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; //从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; //从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; int lastIndexOf(Object o)： 从尾遍历找 12345678910111213141516171819public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; //从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; //从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1;&#125; 检查链表是否包含某对象的方法contains(Object o)： 检查对象o是否存在于链表中 123public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125; 删除方法remove() ,removeFirst(),pop(): 删除头节点 123456789101112public E pop() &#123; return removeFirst();&#125;public E remove() &#123; return removeFirst();&#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125; removeLast()，pollLast(): 删除尾节点 12345678910public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);&#125; 区别： removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。 remove(Object o): 删除指定元素 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; //如果删除对象为null if (o == null) &#123; //从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; //找到元素 if (x.item == null) &#123; //从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; else &#123; //从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; //找到元素 if (o.equals(x.item)) &#123; //从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; return false;&#125; 当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。 unlink(Node&lt;E&gt; x)方法： 123456789101112131415161718192021222324252627E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next;//得到后继节点 final Node&lt;E&gt; prev = x.prev;//得到前驱节点 //删除前驱指针 if (prev == null) &#123; first = next;//如果删除的节点是头节点,令头节点指向该节点的后继节点 &#125; else &#123; prev.next = next;//将前驱节点的后继节点指向后继节点 x.prev = null; &#125; //删除后继指针 if (next == null) &#123; last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点 &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; remove(int index)：删除指定位置的元素 123456public E remove(int index) &#123; //检查index范围 checkElementIndex(index); //将节点删除 return unlink(node(index));&#125; 一些API 返回值 方法参数及作用描述 boolean add(E e) 将指定的元素追加到此列表的末尾。 void add(int index, E element) 在此列表中的指定位置插入指定的元素。 boolean addAll(Collection&lt;? extends E&gt; c) 按照指定集合的迭代器返回的顺序将指定集合中的所有元素追加到此列表的末尾。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 void addFirst(E e) 在该列表开头插入指定的元素。 void addLast(E e) 将指定的元素追加到此列表的末尾。 void clear() 从列表中删除所有元素。 Object clone() 返回此 LinkedList的浅版本。 boolean contains(Object o) 如果此列表包含指定的元素，则返回 true 。 Iterator&lt;E&gt; descendingIterator() 以相反的顺序返回此deque中的元素的迭代器。 E element() 检索但不删除此列表的头（第一个元素）。 E get(int index) 返回此列表中指定位置的元素。 E getFirst() 返回此列表中的第一个元素。 E getLast() 返回此列表中的最后一个元素。 int indexOf(Object o) 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 int lastIndexOf(Object o) 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。 ListIterator&lt;E&gt; listIterator(int index) 从列表中的指定位置开始，返回此列表中元素的列表迭代器（按适当的顺序）。 boolean offer(E e) 将指定的元素添加为此列表的尾部（最后一个元素）。 boolean offerFirst(E e) 在此列表的前面插入指定的元素。 boolean offerLast(E e) 在该列表的末尾插入指定的元素。 E peek() 检索但不删除此列表的头（第一个元素）。 E peekFirst() 检索但不删除此列表的第一个元素，如果此列表为空，则返回 null 。 E peekLast() 检索但不删除此列表的最后一个元素，如果此列表为空，则返回 null 。 E poll() 检索并删除此列表的头（第一个元素）。 E pollFirst() 检索并删除此列表的第一个元素，如果此列表为空，则返回 null 。 E pollLast() 检索并删除此列表的最后一个元素，如果此列表为空，则返回 null 。 E pop() 从此列表表示的堆栈中弹出一个元素。 void push(E e) 将元素推送到由此列表表示的堆栈上。 E remove() 检索并删除此列表的头（第一个元素）。 E remove(int index) 删除该列表中指定位置的元素。 boolean remove(Object o) 从列表中删除指定元素的第一个出现（如果存在）。 E removeFirst() 从此列表中删除并返回第一个元素。 boolean removeFirstOccurrence(Object o) 删除此列表中指定元素的第一个出现（从头到尾遍历列表时）。 E removeLast() 从此列表中删除并返回最后一个元素。 boolean removeLastOccurrence(Object o) 删除此列表中指定元素的最后一次出现（从头到尾遍历列表时）。 E set(int index, E element) 用指定的元素替换此列表中指定位置的元素。 int size() 返回此列表中的元素数。 Spliterator&lt;E&gt; spliterator() 在此列表中的元素上创建late-binding和故障快速 Spliterator 。 Object[] toArray() 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 &lt;T&gt; T[] toArray(T[] a) 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 最后本文阐述了Java集合类LinkedList的内部结构以及部分源码实现，并总结了该集合的一些常用方法。]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】基于Java NIO的多人聊天室]]></title>
    <url>%2FJava%2FIO%2F%E5%9F%BA%E4%BA%8ENIO%E7%9A%84%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[前言学习了NIO的基本原理及使用方法之后，开始尝试写一个NIO实现的聊天室，练习一下代码流程。 服务器端服务器端主要负责接受各客户端的连接，接收客户端发来的信息，并且将其广播给所有已连接客户端。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/** * Created by makersy on 2019 *//** * NIO服务器端 */public class NioServer &#123; /** * 启动 */ public void start() throws IOException &#123; // 1. 创建一个Selector Selector selector = Selector.open(); // 2. 通过ServerSocketChannel创建channel通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 3. 为channel通道绑定监听端口 serverSocketChannel.bind(new InetSocketAddress(8000)); // 4. 设置channel为非阻塞模式 serverSocketChannel.configureBlocking(false); // 5. 将channel注册到selector上，监听连接事件 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //ACCEPT : 接收客户端连接 System.out.println("服务器启动成功"); // 6. 循环等待新接入的连接 for (; ; ) &#123; // 也可while(true) c语言常用：for(;;) //获取可用channel数量 int readyChannels = selector.select(); //select() 是一个阻塞方法 //防止空轮询 if (readyChannels == 0) continue; //获取可用channel的集合 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator iterator = selectionKeys.iterator(); while (iterator.hasNext()) &#123; //selectionKey实例 SelectionKey selectionKey = (SelectionKey) iterator.next(); //移除Set中的当前selectionKey iterator.remove(); // 7. 根据就绪状态，调用对应方法处理业务逻辑 //如果是 接入事件 if (selectionKey.isAcceptable()) &#123; acceptHandler(serverSocketChannel, selector); &#125; //如果是 可读事件 if (selectionKey.isReadable()) &#123; readHandler(selectionKey, selector); &#125; &#125; &#125; &#125; /** * 接入事件处理器 */ private void acceptHandler(ServerSocketChannel serverSocketChannel, Selector selector) throws IOException &#123; //如果是接入事件，创建socketChannel SocketChannel socketChannel = serverSocketChannel.accept(); //将socketChannel设置为非阻塞工作模式 socketChannel.configureBlocking(false); //将socketChannel注册到selector上，监听 可读事件 socketChannel.register(selector, SelectionKey.OP_READ); //回复客户端提示信息 socketChannel.write(Charset.forName("UTF-8") .encode("你与聊天室其他人都不是朋友关系，请注意隐私安全")); &#125; /** * 可读事件处理器，读取客户端发送来的信息，并广播给其他客户端 */ private void readHandler(SelectionKey selectionKey, Selector selector) throws IOException &#123; //要从 selectionKey 中获取到已经就绪的channel SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); //创建一个buffer ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //使用buffer循环读取请求信息 String request = ""; while (socketChannel.read(byteBuffer) &gt; 0) &#123; //切换buffer为读模式 byteBuffer.flip(); //读取buffer中的内容 request += Charset.forName("UTF-8").decode(byteBuffer); &#125; //将 socketChannel 再次注册到selector上，监听 可读事件 socketChannel.register(selector, SelectionKey.OP_READ); //将客户端发送的请求信息广播给其他客户端 if (request.length() &gt; 0) &#123; //广播给其他客户端 broadCast(selector, socketChannel, request); &#125; &#125; //广播给其他客户端 private void broadCast(Selector selector, SocketChannel sourceChannel, String request) &#123; //获取到所有已接入的客户端channel Set&lt;SelectionKey&gt; selectionKeys = selector.keys(); //循环向所有channel广播信息 selectionKeys.forEach(selectionKey -&gt; &#123; Channel targetChannel = selectionKey.channel(); // 发送消息，剔除发消息的客户端 if (targetChannel instanceof SocketChannel &amp;&amp; targetChannel != sourceChannel) &#123; try &#123; //将信息发送到targetChannel客户端 ((SocketChannel) targetChannel).write(Charset.forName("UTF-8").encode(request)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; public static void main(String[] args) &#123; try &#123; new NioServer().start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端启动类向服务器端发送数据。同时新开线程接收服务器端发来的数据。 1234567891011121314151617181920212223242526272829303132333435363738/** * Created by makersy on 2019 *//* NIO客户端，封装启动代码 */public class NioClient &#123; /** * 启动方法 */ public void start(String nickname) throws IOException &#123; //连接服务器端 SocketChannel socketChannel = SocketChannel.open( new InetSocketAddress("127.0.0.1", 8000)); System.out.println("客户端 " + nickname + " 启动成功!"); //接收服务器端响应 Selector selector = Selector.open(); socketChannel.configureBlocking(false); //非阻塞 socketChannel.register(selector, SelectionKey.OP_READ); //注册为接收模式 //需要新开一个线程，专门负责接收服务端的响应数据。因为当前线程需要负责发送给服务器端数据 new Thread(new NioClientHandler(selector)).start(); //新开线程 //向服务器端发送数据 Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) &#123; String request = scanner.nextLine(); if (request != null &amp;&amp; request.length() &gt; 0) &#123; socketChannel.write(Charset.forName("UTF-8").encode(nickname + " : " + request)); &#125; &#125; &#125;&#125; 客户端接收服务器端数据类负责接收服务端发来的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Created by makersy on 2019 *//** * 客户端线程类，专门接收服务器端响应信息 */public class NioClientHandler implements Runnable &#123; private Selector selector; public NioClientHandler(Selector selector) &#123; this.selector = selector; &#125; @Override public void run() &#123; try &#123; for (; ; ) &#123; int readyChannels = selector.select(); if (readyChannels == 0) continue; Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator iterator = selectionKeys.iterator(); while (iterator.hasNext()) &#123; SelectionKey selectionKey = (SelectionKey) iterator.next(); iterator.remove(); if (selectionKey.isReadable()) &#123; readHandler(selectionKey, selector); &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 可读事件处理器 */ private void readHandler(SelectionKey selectionKey, Selector selector) throws IOException &#123; //要从 selectionKey 中获取到已经就绪的channel SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); //创建一个buffer ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //使用buffer循环读取服务器端请求信息 String response = ""; while (socketChannel.read(byteBuffer) &gt; 0) &#123; //切换buffer为读模式 byteBuffer.flip(); //读取buffer中的内容 response += Charset.forName("UTF-8").decode(byteBuffer); &#125; //将 socketChannel 再次注册到selector上，监听 可读事件 socketChannel.register(selector, SelectionKey.OP_READ); //将服务器端响应信息打印到本地 if (response.length() &gt; 0) &#123; System.out.println(response); &#125; &#125;&#125; 实例：A客户端、B客户端到这里服务器端和客户端响应启动代码就已经完成了，如果我们需要连接到服务器端进入群聊，只要新开一个线程，命名即可。 假设我新建一个AClient，代码如下： 123456789/** * Created by makersy on 2019 */public class AClient &#123; public static void main(String[] args) throws IOException &#123; new NioClient().start("AClient"); &#125;&#125; 再次创建新线程流程同上面一样。 效果演示A客户端 B客户端 最后不得不说，NIO的程序还是挺难写的，而且还会出现许多的问题。像我写的这么简单的代码就肯定有很多bug存在，更别说复杂的业务代码了。这也应该就是大多数人不使用JDK原生NIO进行网络编程的原因了。]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】浅谈IO与NIO]]></title>
    <url>%2FJava%2FIO%2F%E3%80%90Java%E3%80%91IO%E3%80%81NIO%2F</url>
    <content type="text"><![CDATA[前言Java IO，即Java中的输入输出，可以用来数据的写入和读出。在整个Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable。本文主要总结IO流、NIO相关知识。 IO流的分类 按照流的流向分，可以分为输入流和输出流 输入流： 只能从中读取数据，而不能向其写入数据。 输出流：只能向其写入数据，而不能向其读取数据。 按照操作单元划分，可以划分为字节流和字符流 字节流和字符流的用法几乎完成全一样，区别在于字节流和字符流所操作的数据单元不同，字节流操作的单元是数据单元是8位的字节，字符流操作的是数据单元为16位的字符。 字节流主要是由InputStream和outPutStream作为基类，而字符流则主要有Reader和Writer作为基类。 按照流的角色，划分为节点流和处理流。 可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，称为节点流。节点流也被称为低级流。图15.3显示了节点流的示意图。 按操作单元及方式分类如下图： java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 关于IO详细的原理及api，详见java IO体系的学习总结。 NIONIO简介Java NIO 是 java 1.4, 之后新出的一套IO接口NIO中的N可以理解为Non-blocking，不单纯是New。 传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。 NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。 BIO中的accept是没有客户端连接时阻塞，NIO的accept是没有客户端连接时立即返回。 NIO的特性/NIO与IO区别: IO是面向流的，NIO是面向缓冲区的； IO流是阻塞的，NIO流是不阻塞的; NIO有选择器，而IO没有。 读数据和写数据方式: 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。 NIO核心组件简单介绍 NIO的三个重要组件：Buffer、Channel、Selector。 Buffer是用于容纳数据的缓冲区，Channel是与IO设备之间的连接，类似于流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。 Selector是Channel的多路复用器。 Buffer(缓冲区) Java NIO Buffers用于和NIO Channel交互。 我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels； Buffer本质上就是一块内存区； 一个Buffer有三个属性是必须掌握的，分别是：capacity容量、position位置、limit限制。 capacity：代表buffer的总容量； position：写模式下，代表当前第一个可插入数据的位置；读模式下，代表第一个可以读取的数据； limit：写模式下，代表最多能往buffer中写数据的数量，即为capacity；读模式下，代表最多可从buffer中读取多少数据，此时limit将变为写模式下的position值； mark：代表一个特定的position位置，调用reset方法后可以继续从此位置处理数据。 Buffer的常见方法 Buffer clear()：将所有属性重置 Buffer flip()：从写模式切换到读模式 Buffer rewind() Buffer position(int newPosition) mark()：记录当前position位置 get()：获取下一个字节 Buffer的使用方式/方法介绍: 分配缓冲区（Allocating a Buffer）: 1ByteBuffer buf = ByteBuffer.allocate(28);//以ByteBuffer为例子 写入数据到缓冲区（Writing Data to a Buffer） 写数据到Buffer有两种方法： 1.从Channel中写数据到Buffer 1int bytesRead = inChannel.read(buf); //read into buffer. 2.通过put写数据： 1buf.put(127); 核心缓冲区介绍 覆盖了Java IO发送的基本的数据类型： ByteBuffer CharBuffer ShortBuffer IntBuffer FloatBuffer DoubleBuffer LongBuffer Channel(通道) Channel（通道）介绍 通常来说NIO中的所有IO都是从 Channel（通道） 开始的，它与IO设备的连接，与stream是平级的概念。 从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。 从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。 流与通道的区别 1、流是单向的，通道是双向的，可读可写。 2、流读写是阻塞的，通道可以异步读写。 3、流中的数据可以选择性的先读到缓存中，通道的数据总是要先读到一个缓存中，或从缓存中写入 Channel接口的主要实现类 FileChannel：用于读取、写入、映射和操作文件的通道 DatagramChannel：通过UDP读写网络中的数据通道 SocketChannel：通过TCP读写网络中的数据 ServerSocketChannel：监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel 注意，FileChannel不能设置为非阻塞模式。 获取通道的方式 一种方式是对支持通道的对象调用getChannel()方法。支持通道的类如下： FileInputStream FileOutputStream RandomAccessFile DatagramSocket Socket ServerSocket 获取通道的其他方式是使用Files类的静态方法newByteChannel()获取字节通道。或者通过通道的静态方法open()打开并返回指定通道。 Scatter / Gather Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer)。 Gather: 将N个Buffer里面内容按照顺序发送到一个Channel。 通道之间的数据传输 在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。 transferFrom() :transferFrom方法把数据从通道源传输到FileChannel transferTo() :transferTo方法把FileChannel数据传输到另一个channel FileChannel与文件锁 在通道中我们可以对文件或者部分文件进行上锁。上锁和我们了解的线程锁差不多，都是为了保证数据的一致性。在文件通道FileChannel中可以对文件进行上锁，通过FileLock可以对文件进行锁的释放。 文件加锁是建立在文件通道（FileChannel）之上的，套接字通道（SockeChannel）不考虑文件加锁，因为它是不共享的。它对文件加锁有两种方式： lock tryLock 两种加锁方式默认都是对整个文件加锁，如果自己配置的话就可以控制加锁的文件范围：position是加锁的开始位置，size是加锁长度，shared是用于控制该锁是共享的还是独占的。 lock是阻塞式的，当有进程对锁进行读取时会等待锁的释放，在此期间它会一直等待；tryLock是非阻塞式的，它尝试获得锁，如果这个锁不能获得，那么它会立即返回。 release可以释放锁。 在一个进程中在锁没有释放之前是无法再次获得锁的。 在java的NIO中，通道包下面有一个FileLock类，它主要是对文件锁工具的一个描述。在上一小节中对文件的锁获取其实是FileChannel获取的（lock与trylock是FileChannel的方法），它们返回一个FileLock对象。这个类的核心方法有如下这些： 1234567891011boolean isShared() :判断锁是否为共享类型 abstract boolean isValid() ：判断锁是否有效 boolean overlaps()：判断此锁定是否与给定的锁定区域重叠 long position()：返回文件内锁定区域中第一个字节的位置。 abstract void release() ：释放锁 long size() ：返回锁定区域的大小，以字节为单位 在文件锁中有3种方式可以释放文件锁：1、锁类释放锁，调用FileLock的release方法； 2、通道类关闭通道，调用FileChannel的close方法；3、jvm虚拟机会在特定情况释放锁。 锁类型（独占式和共享式） 我们先区分一下在文件锁中两种锁的区别：①独占式的锁就想我们上面测试的那样，只要有一个进程获取了独占锁，那么别的进程只能等待。②共享锁在一个进程获取的情况下，别的进程还是可以读取被锁定的文件，但是别的进程不能写只能读。 Selector(选择器) Selector（选择器）介绍 Selector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。它是非阻塞IO的核心。 使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。 Selector（选择器）的使用方法介绍 Selector可以去监听的请求有以下几类： 1、connect：客户端连接服务端事件，对应值为SelectionKey.OP_CONNECT 2、accept：服务端接收客户端连接事件，对应值为SelectionKey.OP_ACCEPT 3、read：读事件，对应值为SelectionKey.OP_READ 4、write：写事件，对应值为SelectionKey.OP_WRITE 每次请求到达服务器，都是从connect开始，connect成功后，服务端开始准备accept，准备就绪，开始读数据，并处理，最后写回数据返回。 SelectionKey是一个复合事件，一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。绑定到某个selector对应的某个channel上，可能是多个事件的复合或单一事件。 Selector的创建 1Selector selector = Selector.open(); 注册Channel到Selector并传入监听事件(Channel必须是非阻塞的) 12channel.configureBlocking(false);SelectionKey key = channel.register(selector, Selectionkey.OP_READ); 最后NIO的东西是很多的，因为需要熟悉Java中为其设计的很多api以及操作系统的概念。]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】ArrayList详解]]></title>
    <url>%2FJava%2F%E9%9B%86%E5%90%88%2F%E3%80%90Java%E3%80%91ArrayList%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ArrayList简介 ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。 它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。 在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为O（n）,求表长以及增加元素，取第 i 元素的时间复杂度为O（1） ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。 ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，能被克隆。 ArrayList 实现java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。 和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。 ArrayList核心源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组（用于空实例）。 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存ArrayList数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList 所包含的元素个数 */ private int size; /** * 带初始容量参数的构造函数。（用户自己指定容量） */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; //创建空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; /** *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; // elementData = c.toArray(); //如果指定集合元素个数不为0 if ((size = elementData.length) != 0) &#123; // c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断， //这里用到了反射里面的getClass()方法 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 用空数组代替 this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125;//下面是ArrayList的扩容机制//ArrayList的扩容机制提高了性能，如果每次只扩充一个，//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; //判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125; /** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法。 */ private void grow(int minCapacity) &#123; // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; //比较minCapacity和 MAX_ARRAY_SIZE private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** *返回此列表中的元素数。 */ public int size() &#123; return size; &#125; /** * 如果此列表不包含元素，则返回 true 。 */ public boolean isEmpty() &#123; //注意=和==的区别 return size == 0; &#125; /** * 如果此列表包含指定的元素，则返回true 。 */ public boolean contains(Object o) &#123; //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 return indexOf(o) &gt;= 0; &#125; /** *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) //equals()方法比较 if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） */ public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // 这不应该发生，因为我们是可以克隆的 throw new InternalError(e); &#125; &#125; /** *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。 *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。 */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。 *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） */ @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // 新建一个运行时类型的数组，但是ArrayList数组的内容 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); //调用System提供的arraycopy()方法实现数组之间的复制 System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // Positional Access Operations @SuppressWarnings("unchecked") E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 返回此列表中指定位置的元素。 */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 用指定的元素替换此列表中指定位置的元素。 */ public E set(int index, E element) &#123; //对index进行界限检查 rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; //返回原来在这个位置的元素 return oldValue; &#125; /** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! //这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true; &#125; /** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work //从列表中删除的元素 return oldValue; &#125; /** * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。 *返回true，如果此列表包含指定的元素 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 从列表中删除所有元素。 */ public void clear() &#123; modCount++; // 把数组中所有的元素的值设为null for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。 *将任何后续元素移动到左侧（减少其索引）。 */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 检查给定的索引是否在范围内。 */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * add和addAll使用的rangeCheck的一个版本 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 返回IndexOutOfBoundsException细节信息 */ private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+size; &#125; /** * 从此列表中删除指定集合中包含的所有元素。 */ public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); //如果此列表被修改则返回true return batchRemove(c, false); &#125; /** * 仅保留此列表中包含在指定集合中的元素。 *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; /** * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 *返回的列表迭代器是fail-fast 。 */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index); &#125; /** *返回列表中的列表迭代器（按适当的顺序）。 *返回的列表迭代器是fail-fast 。 */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** *以正确的顺序返回该列表中的元素的迭代器。 *返回的迭代器是fail-fast 。 */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; ArrayList源码分析System.arraycopy()和Arrays.copyOf()方法 通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面add(int index, E element)方法就很巧妙的用到了arraycopy()方法让数组自己复制自己实现让index开始之后的所有成员后移一个位置: 123456789101112131415/** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()方法实现数组自己复制自己 //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 又如toArray()方法中用到了copyOf()方法 123456789/** *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。 *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。 */public Object[] toArray() &#123;//elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size);&#125; 两者联系与区别联系：看两者源代码可以发现copyOf()内部调用了System.arraycopy()方法区别： arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置 copyOf()是系统自动在内部新建一个数组，并返回该数组。 ArrayList 核心扩容技术1234567891011121314151617181920212223242526272829303132333435363738//下面是ArrayList的扩容机制//ArrayList的扩容机制提高了性能，如果每次只扩充一个，//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; //判断是否需要扩容,上面两个方法都要调用 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。 //这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1 if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125; 12345678910111213141516171819202122/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) &#123; //elementData为保存ArrayList数据的数组 ///elementData.length求数组长度elementData.size是求数组中的元素个数 // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：移位运算符 简介：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移)和&gt;&gt;&gt;(无符号右移)。 作用：对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。 另外需要注意的是： java 中的length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性. java 中的length()方法是针对字符串String说的,如果想看这个字符串的长度则用到 length()这个方法. .java 中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看! 内部类1234(1)private class Itr implements Iterator&lt;E&gt; (2)private class ListItr extends Itr implements ListIterator&lt;E&gt; (3)private class SubList extends AbstractList&lt;E&gt; implements RandomAccess (4)static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; ArrayList有四个内部类，其中的Itr是实现了Iterator接口，同时重写了里面的hasNext()，next()，remove()等方法；其中的ListItr继承Itr，实现了ListIterator接口，同时重写了hasPrevious()，nextIndex()，previousIndex()，previous()，set(E e)，add(E e)等方法，所以这也可以看出了 Iterator和ListIterator的区别:ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。 演示demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package list;import java.util.ArrayList;import java.util.Iterator;public class ArrayListDemo &#123; public static void main(String[] srgs)&#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); System.out.printf("Before add:arrayList.size() = %d\n",arrayList.size()); arrayList.add(1); arrayList.add(3); arrayList.add(5); arrayList.add(7); arrayList.add(9); System.out.printf("After add:arrayList.size() = %d\n",arrayList.size()); System.out.println("Printing elements of arrayList"); // 三种遍历方式打印元素 // 第一种：通过迭代器遍历 System.out.print("通过迭代器遍历:"); Iterator&lt;Integer&gt; it = arrayList.iterator(); while(it.hasNext())&#123; System.out.print(it.next() + " "); &#125; System.out.println(); // 第二种：通过索引值遍历 System.out.print("通过索引值遍历:"); for(int i = 0; i &lt; arrayList.size(); i++)&#123; System.out.print(arrayList.get(i) + " "); &#125; System.out.println(); // 第三种：for循环遍历 System.out.print("for循环遍历:"); for(Integer number : arrayList)&#123; System.out.print(number + " "); &#125; // toArray用法 // 第一种方式(最常用) Integer[] integer = arrayList.toArray(new Integer[0]); // 第二种方式(容易理解) Integer[] integer1 = new Integer[arrayList.size()]; arrayList.toArray(integer1); // 抛出异常，java不支持向下转型 //Integer[] integer2 = new Integer[arrayList.size()]; //integer2 = arrayList.toArray(); System.out.println(); // 在指定位置添加元素 arrayList.add(2,2); // 删除指定位置上的元素 arrayList.remove(2); // 删除指定元素 arrayList.remove((Object)3); // 判断arrayList是否包含5 System.out.println("ArrayList contains 5 is: " + arrayList.contains(5)); // 清空ArrayList arrayList.clear(); // 判断ArrayList是否为空 System.out.println("ArrayList is empty: " + arrayList.isEmpty()); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写简易版Spring框架-2]]></title>
    <url>%2FSpring%2F%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%89%88Spring%E6%A1%86%E6%9E%B6-2%2F</url>
    <content type="text"><![CDATA[前言Spring框架作为当前最流行的JavaEE框架之一，简化了代码，提升了性能。而在这其中最主要的技术就是依赖注入了。所谓依赖注入，就是创建被调用者的工作由spring来完成，然后将其注入调用者。 本篇主要介绍了依赖注入和控制反转，并分析了上一篇中，依赖注入的代码实现原理。 关于BeanBean的特点： 生命周期较长 在整个虚拟机内可见 维护成本高，单例存在 Bean优势 运行期效率高 统一维护，便于管理和扩展 维护成本高，因此单例存在 Bean的创建普通创建方式 上图中就可以看到，如果按照普通的类创建方式，A类中有成员C，B类中有成员C，C类中有成员B，那么我们如果为A、B、C类各创建有一个对象，那么堆中就会有1个A对象、2个B对象、1个C对象和3个Z对象，十分地浪费资源。 Spring实现方式 包扫描并自动装配（反射） BeanFactory（统一管理） 依赖注入 控制反转 / 依赖注入 IoC（Invension of Control）：思想 DI（Dependency Injection）：方式 Bean创建方式 Spring中采用了BeanFactory来管理Bean，需要时就将Bean注入。其创建方式如下图： 使用单例BeanFactory来管理Bean，使得所有的Bean都是单例，在JVM中只有一个，相比于普通类创建方式，大大地节约了资源。 实现依赖注入 扫描包获得类定义 初始化Bean，并实现依赖注入 解决Bean初始化顺序问题 依赖注入次序问题 由图中可以看出整个依赖注入的流程，首先就是判断要创建的Bean里面是否含有依赖，如果没有依赖就直接创建并放入BeanFactory，如果有依赖就进行下一步；判断BeanFactory中是否含有所需的依赖，如果有的话就直接set到Bean中，如果没有就先放弃创建当前Bean，先创建后面的，后面的创建完了再来从头遍历前面创建失败的Bean。这里要注意一个问题：如果Bean之间相互依赖就会出现死循环问题。要解决它，我们可以在遍历完后检查要创建的Bean是否减少，如果Bean没有减少，说明陷入循环依赖，这时就要抛出异常，退出死循环。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC基础]]></title>
    <url>%2Funcategorized%2FSpringMVC%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[DispatcherServlet Spring采用了一个Dispatcherservlet来进行请求分发，所有请求都会经过这个servlet，然后根据现有mapping handler进行请求uri匹配进行处理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[手写简易版Spring框架-1]]></title>
    <url>%2FSpring%2F%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%89%88Spring%E6%A1%86%E6%9E%B6-1%2F</url>
    <content type="text"><![CDATA[前言为了巩固学习Spring框架，我尝试通过手写spring，实现SpringMVC基本功能来学习Spring源码。 实现功能这次先写了一个简易的框架，实现了最基本的IoC功能，以及springmvc中常用的注解，具体如下: @Controller @RequestMapping @RequestParam @Autowired @Bean 代码内嵌服务器采用了apache的embed-core包在项目中内置了一个tomcat服务器，直接调用一个自己写的start()方法即可启动。本包在gradle中依赖如下： 12// https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-corecompilegroup: 'org.apache.tomcat.embed', name: 'tomcat-embed-core', version: '8.5.23' 下面是TomcatServer类： 1234567891011121314151617181920212223242526272829303132333435363738/** * Created by makersy on 2019 */public class TomcatServer &#123; private Tomcat tomcat; private String[] args; public TomcatServer(String[] args) &#123; this.args = args; &#125; //启动类 public void startTomcat() throws LifecycleException &#123; tomcat = new Tomcat(); tomcat.setPort(6699); tomcat.start(); Context context = new StandardContext(); context.setPath(""); context.addLifecycleListener(new Tomcat.FixContextListener()); //默认监听器 DispatcherServlet servlet = new DispatcherServlet(); //前端控制器 Tomcat.addServlet(context, "dispatcherServlet", servlet).setAsyncSupported(true); //支持异步的servlet context.addServletMappingDecoded("/", "dispatcherServlet"); //为Servlet绑定映射，/表示可以处理所有uri tomcat.getHost().addChild(context); Thread awaitThread = new Thread("tomcat_await_thread")&#123; @Override public void run() &#123; TomcatServer.this.tomcat.getServer().await(); //声明该线程一直在等待 &#125; &#125;; //设置为非守护线程 awaitThread.setDaemon(false); //使该线程等待 awaitThread.start(); &#125;&#125; DispatcherServlet（用来维护Servlet）DispatcherServlet类进行servlet的维护，实现请求分发。 123456789101112131415161718192021222324252627282930313233343536373839/** * Created by makersy on 2019 */public class DispatcherServlet implements Servlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; for (MappingHandler mappingHandler : HandlerManager.mappingHandlerList) &#123; try &#123; if (mappingHandler.handle(req, res)) &#123; return; &#125; &#125; catch (IllegalAccessException | InstantiationException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; MappingHandlerMappingHandler用来处理经过dispatcherservlet的请求uri，每个MappingHandler处理其匹配的uri请求。 12345678910111213141516171819202122232425262728293031323334/** * Created by makersy on 2019 */public class MappingHandler &#123; private String uri; private Method method; private Class&lt;?&gt; controller; private String[] args; public boolean handle(ServletRequest request, ServletResponse response) throws IllegalAccessException, InstantiationException, InvocationTargetException, IOException &#123; String requestUri = ((HttpServletRequest)request).getRequestURI(); if (!uri.equals(requestUri)) &#123; return false; &#125; Object[] parameters = new Object[args.length]; for (int i = 0; i &lt; args.length; i++) &#123; parameters[i] = request.getParameter(args[i]); &#125; Object ctl = BeanFactory.getBean(controller); Object res = method.invoke(ctl, parameters); response.getWriter().println(res.toString()); return true; &#125; public MappingHandler(String uri, Method method, Class&lt;?&gt; controller, String[] args) &#123; this.uri = uri; this.method = method; this.controller = controller; this.args = args; &#125;&#125; HandlerManagerHandlerManager负责处理controller注解，将其转换为handler。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Created by makersy on 2019 */public class HandlerManager &#123; public static List&lt;MappingHandler&gt; mappingHandlerList = new ArrayList&lt;&gt;(); /** * 将list中的controller转化为MappingHandler * @param classList 类列表 */ public static void resolveMappingHandler(List&lt;Class&lt;?&gt;&gt; classList) &#123; for (Class&lt;?&gt; cls : classList) &#123; if (cls.isAnnotationPresent(Controller.class)) &#123; parseHandlerFromController(cls); &#125; &#125; &#125; /** * 将controller转化为handler * @param cls */ private static void parseHandlerFromController(Class&lt;?&gt; cls) &#123; Method[] methods = cls.getDeclaredMethods(); for (Method method : methods) &#123; //判断方法是否有RequestMapping注解 if (!method.isAnnotationPresent(RequestMapping.class)) &#123; continue; &#125; String uri = method.getDeclaredAnnotation(RequestMapping.class).value(); List&lt;String&gt; paramNameList = new ArrayList&lt;&gt;(); //获取method的带有RequestParam注解的参数，形成一个list for (Parameter parameter : method.getParameters()) &#123; if (parameter.isAnnotationPresent(RequestParam.class)) &#123; paramNameList.add(parameter.getDeclaredAnnotation(RequestParam.class).value()); &#125; &#125; String[] params = paramNameList.toArray(new String[paramNameList.size()]); MappingHandler mappingHandler = new MappingHandler(uri, method, cls, params); HandlerManager.mappingHandlerList.add(mappingHandler); &#125; &#125;&#125; ClassScanner负责扫描一个jar包下面的所有类。用于初始化时获取所有类的列表，从而进行依赖注入，以及controller扫描。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Created by makersy on 2019 */public class ClassScanner &#123; /** * 扫描一个包下面的所有类 * @param packageName 包名 * @return * @throws IOException * @throws ClassNotFoundException */ public static List&lt;Class&lt;?&gt;&gt; scanClass(String packageName) throws IOException, ClassNotFoundException &#123; List&lt;Class&lt;?&gt;&gt; classList = new ArrayList&lt;&gt;(); String path = packageName.replace(".", "/"); //将包名转化为路径名 ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); //获取类加载器 Enumeration&lt;URL&gt; resources = classLoader.getResources(path); while (resources.hasMoreElements()) &#123; URL resource = resources.nextElement(); if (resource.getProtocol().contains("jar")) &#123; //如果资源类型是jar包 JarURLConnection jarURLConnection = (JarURLConnection) resource.openConnection(); String jarFilePath = jarURLConnection.getJarFile().getName(); classList.addAll(getClassesFromJar(jarFilePath, path)); &#125; else &#123; //todo &#125; &#125; return classList; &#125; /** * 获取一个jar包下所有类 * @param jarFilePath * @param path * @return 类的list * @throws IOException * @throws ClassNotFoundException */ private static List&lt;Class&lt;?&gt;&gt; getClassesFromJar(String jarFilePath, String path) throws IOException, ClassNotFoundException &#123; List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;(); JarFile jarFile = new JarFile(jarFilePath); Enumeration&lt;JarEntry&gt; jarEntries = jarFile.entries(); while (jarEntries.hasMoreElements()) &#123; JarEntry jarEntry = jarEntries.nextElement(); String entryName = jarEntry.getName(); if (entryName.startsWith(path) &amp;&amp; entryName.endsWith(".class")) &#123; String classFullName = entryName.replace("/", ".").substring(0, entryName.length() - 6); //类的全限定名 classes.add(Class.forName(classFullName)); &#125; &#125; return classes; &#125;&#125; Controller、RequestMapping和RequestParam注解关于注解，可以参考我之前的文章：Java的注解 Controller 123456789/** * Created by makersy on 2019 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Controller &#123;&#125; RequestMapping 12345678910/** * Created by makersy on 2019 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface RequestMapping &#123; String value();&#125; RequestParam 12345678910/** * Created by makersy on 2019 */@Documented@Retention(RetentionPolicy.RUNTIME) //保存级别@Trget(ElementType.PARAMETER)public @interface RequestParam &#123; String value();&#125; BeanFactory这个是IoC的重点部分，所有的依赖都是由BeanFactory处理并注入的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package top.makersy.beans;import top.makersy.web.mvc.Controller;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * Created by makersy on 2019 */public class BeanFactory &#123; //用一个类和实例的映射来模拟Bean工厂 private static Map&lt;Class&lt;?&gt;, Object&gt; classToBean = new ConcurrentHashMap&lt;&gt;(); //从映射中获取Bean public static Object getBean(Class&lt;?&gt; cls)&#123; return classToBean.get(cls); &#125; /** * Bean初始化，将表中所有类的依赖都加入 classToBean 这个映射中 * @param classList 包中所有类的集合 * @throws Exception */ public static void initBean(List&lt;Class&lt;?&gt;&gt; classList) throws Exception &#123; List&lt;Class&lt;?&gt;&gt; toCreate = new ArrayList&lt;&gt;(classList); //新建1个list来存放，以免改变了传入List的值 //一一初始化每一个类直到将类集合全部初始化完为止 while (toCreate.size() != 0) &#123; int remainSize = toCreate.size(); for (int i = 0; i &lt; toCreate.size(); i++) &#123; if (finishCreate(toCreate.get(i))) &#123; toCreate.remove(i); &#125; &#125; // 当要创建的Bean列表长度始终不变时，说明出现了Bean之间相互依赖的问题。 // 因为我们采取的策略是当前Bean创建失败就去创建下一个，这样后面的创建完了有来重新创建前 // 面的依赖，如果这个阶段了list长度始终不变，那么说明Bean之间存在相互的依赖，A不创建B没 // 法创建，B不创建A也没法创建。 // 这里不进行处理，而是直接抛出异常 if (toCreate.size() == remainSize) &#123; throw new Exception("cycle dependency!"); &#125; &#125; &#125; private static boolean finishCreate(Class&lt;?&gt; cls) throws IllegalAccessException, InstantiationException &#123; if (!cls.isAnnotationPresent(Bean.class) &amp;&amp; !cls.isAnnotationPresent(Controller.class)) &#123; return true; &#125; Object bean = cls.newInstance(); //获取所有字段，处理其中需要自动注入的 for (Field field : cls.getDeclaredFields()) &#123; //处理 autowired 注解，自动注入 if (field.isAnnotationPresent(Autowired.class)) &#123; Class&lt;?&gt; fieldType = field.getType(); Object relianBean = BeanFactory.getBean(fieldType); //从BeanFactory中获取依赖的Bean //注意这里在BeanFactory中没有找到依赖的Bean时就返回false，放弃创建当前Bean，转而创建后面的。 if (relianBean == null) &#123; return false; &#125; field.setAccessible(true); //关闭安全检查 field.set(bean, relianBean); //将bean的field值更新为relianBean，field值即需要注入的依赖 &#125; &#125; classToBean.put(cls, bean); return true; &#125;&#125; Autowired、Bean注解Autowired 123456789/** * Created by makersy on 2019 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface Autowired &#123;&#125; Bean 123456789/** * Created by makersy on 2019 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Bean &#123;&#125; 最后因为是刚开始，所以只实现了一些基础功能，ioc的循环依赖处理、aop都还没有实现，后面我会在此基础上进行完善。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可能是最全的git忽略文件规则.gitignore文件]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FGit%2F%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E8%A7%84%E5%88%99-gitignore%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[转自http://blog.csdn.net/li396864285/article/details/72738895 gitignore可以防止不相关系统自动产生的文件提交到git上。该文件放置到git项目的根目录下，能够让git忽略符合.gitignore中文件后缀的文件，不会被添加到git版本控制中。 .gitignore中的文件后缀列表大多是系统自动产生的，上传到git是毫无意义的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177# DIYtarget/# svn.svn/# Linux System*~# KDE directory preferences.directory# Linux trash folder which might appear on any partition or disk.Trash-*# Windows System# Windows image file cachesThumbs.dbehthumbs.db# Folder config fileDesktop.ini# Recycle Bin used on file shares$RECYCLE.BIN/# Windows Installer files*.cab*.msi*.msm*.msp# Windows shortcuts*.lnk# OSX System.DS_Store.AppleDouble.LSOverride# Icon must end with two \rIcon# Thumbnails._*# Files that might appear in the root of a volume.DocumentRevisions-V100.fseventsd.Spotlight-V100.TemporaryItems.Trashes.VolumeIcon.icns# Directories potentially created on remote AFP share.AppleDB.AppleDesktopNetwork Trash FolderTemporary Items.apdisk# Eclipse*.pydevproject.metadata.gradlebin/tmp/*.tmp*.bak*.swp*~.niblocal.properties.settings/.loadpath# Eclipse Core.project# External tool builders.externalToolBuilders/# Locally stored "Eclipse launch configurations"*.launch# CDT-specific.cproject# JDT-specific (Eclipse Java Development Tools).classpath# Java annotation processor (APT).factorypath# PDT-specific.buildpath# sbteclipse plugin.target# TeXlipse plugin.texlipse# JetBrains# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio*.iml## Directory-based project format:.idea/# if you remove the above rule, at least ignore the following:# User-specific stuff:# .idea/workspace.xml# .idea/tasks.xml# .idea/dictionaries# Sensitive or high-churn files:# .idea/dataSources.ids# .idea/dataSources.xml# .idea/sqlDataSources.xml# .idea/dynamic.xml# .idea/uiDesigner.xml# Gradle:# .idea/gradle.xml# .idea/libraries# Mongo Explorer plugin:# .idea/mongoSettings.xml## File-based project format:*.ipr*.iws## Plugin-specific files:# IntelliJ/out/# mpeltonen/sbt-idea plugin.idea_modules/# JIRA pluginatlassian-ide-plugin.xml# Crashlytics plugin (for Android Studio and IntelliJ)com_crashlytics_export_strings.xmlcrashlytics.propertiescrashlytics-build.properties# JAVA*.class# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.ear# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*#Maventarget/**/target/pom.xml.tagpom.xml.releaseBackuppom.xml.versionsBackuppom.xml.nextrelease.propertiesdependency-reduced-pom.xmlbuildNumber.properties.mvn/timing.propertieslogs/]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-正则表达式匹配]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数用来匹配包括&#39;.&#39;和 &#39;*&#39; 的正则表达式。模式中的字符&#39;.&#39;表示任意一个字符，而 &#39;*&#39; 表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。 题解 markdown里面的 * 需要转义，一个个转实在有点麻烦，还是把文字放在代码块里好了。 1234567891011121314151617我们可以把问题转换为当前字符的下一个字符是否为 * 来处理，那么就归纳为以下几种情况：1. 如果字符串当前位置的下一个字符不是*，那么： # 字符串与模式的当前位置字符匹配：字符串和模式的索引均向后移一位，继续匹配之后的； # 字符串与模式的当前位置字符不匹配：返回false。 2. 如果字符串当前位置下一个字符是*，那么： # 如果当前位置字符不匹配：模式索引后移2位，字符串不变，相当于 x* 这两个字符被忽略掉， 因为 * 可以匹配0次； # 如果当前位置字符匹配，有三种方式继续匹配，采取递归来一一试探： ## 模式索引后移2位，字符串不变，相当于 x* 这两个字符被忽略掉； 这里解释下为什么这么做。 举个栗子，"bbbba"和".*a"，如果到了第4个b的时候没有把".*"给跳过去，那么 ".*"还会继续匹配下个字符a，那么模式中的a就得不到匹配，返回false。实际上 如果".*"匹配了4个b，然后再匹配最后那个a，是true的； ## 字符串索引后移1位，模式不变，即使用当前字符继续匹配字符串，因为 * 可以匹配多次； ## 字符串索引后移1位，模式后移2位，即 x* 只匹配1次。 代码如下： 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if( str==null || pattern==null ) return false; return matchSub(str, 0, pattern, 0); &#125; public boolean matchSub(char[] str, int strIdx, char[] p, int pIdx)&#123; //如果匹配完成，返回true if( strIdx==str.length &amp;&amp; pIdx==p.length ) return true; //如果pattern先到最后，返回false，这样的话匹配是必定失败的 if( strIdx != str.length &amp;&amp; pIdx==p.length ) return false; //第二个是* if( pIdx+1 &lt; p.length &amp;&amp; p[pIdx+1]=='*' )&#123; //字符串没到尾，且当前位置匹配，三种情况 if( strIdx!=str.length &amp;&amp; str[strIdx]==p[pIdx] || strIdx != str.length &amp;&amp; p[pIdx]=='.' )&#123; return matchSub(str, strIdx, p, pIdx+2) || matchSub(str, strIdx+1, p, pIdx) || matchSub(str, strIdx+1, p, pIdx+2); &#125;else &#123; //字符串到尾，或者当前位置不匹配，都把模式向后移动2位，因为*是可以匹配0次的 return matchSub(str, strIdx, p, pIdx+2); &#125; &#125; //第二个不是*，且当前位置匹配 if( strIdx != str.length &amp;&amp; (str[strIdx] == p[pIdx] || p[pIdx]=='.') )&#123; return matchSub(str, strIdx+1, p, pIdx+1); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的注解]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2FJava%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[介绍注解（Annotation ），有标记、注释的意思，也被称为元数据，他为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。在 Java 中注解是一个很重要的知识点。 Java 注解是从 Java SE5 引入的。他可以提供用来完整描述程序所需的信息，为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且是供指定的工具或框架使用的。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。 标准注解注解的语法比较简单，除了@符号的使用之外，基本与Java固有语法无异。JDK5内置了三种，定义在java.lang中的注解： @Override，表示当前方法定义将覆盖超类中方法。如果将这个单词拼写错误，或者方法签名对应不上被覆盖的方法，那么编译器就会发出错误提示。 @Deprecated，如果使用了注解为这个单词的元素，那么编译器就会发出警告。 @SuppressWarnings，关闭不当的编译器警告信息。 元注解元注解专职负责注解其他注解，Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。 @Target：用于描述该注解的适用范围： 12345678取值(ElementType)有： 1.CONSTRUCTOR:用于描述构造器 2.FIELD:用于描述域（包括enum实例） 3.LOCAL_VARIABLE:用于描述局部变量 4.METHOD:用于描述方法 5.PACKAGE:用于描述包 6.PARAMETER:用于描述参数 7.TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention：表示需要在什么级别保存该注解信息 (生命周期) 某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。 1234取值（RetentionPoicy）有： 1.SOURCE:在源文件中有效（即源文件保留），会被编译器丢弃 2.CLASS:在class文件中有效（即class保留），但会被VM丢弃 3.RUNTIME:在运行时有效（即运行时保留），可以通过反射机制读 取注解的信息 @Documented：包含在Javadoc中 描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化 @Inherited：允许子类继承父类中的注解 如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。 当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 自定义注解12定义注解格式： public @interface 注解名 &#123;定义体&#125; 关于Annotation类型里面的参数该怎么设定:第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型； 第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String。 注解的使用刚接触注解时，我想很多人都会有一个疑问，这个东西有什么用呢？官方文档给了我们答案： 注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。 注解有许多用处，主要如下： 提供信息给编译器： 编译器可以利用注解来探测错误和警告信息 编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。 运行时的处理： 某些注解可以在程序运行的时候接受代码的提取值得注意的是，注解不是代码本身的一部分。 在Spring中大量使用了注解，比如常用的@Controller、@Service等，这些注解大大简化了方法的配置工作。 在此我用上述作用的第一个：提供信息给编译器，来做一个示范。 假设我在一个类里面定义了很多方法，我需要检查每一个方法是否有异常，并将其一一打印，那么我就可以在需要检查的方法上加一个注解，然后用反射的方法来调用方法并获取其注解，判断并打印之。 首先是注解类： 123456789/** * Created by makersy on 2019 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface CheckException &#123; public String description() default "no description";&#125; 然后是方法类： 12345678910111213141516171819202122232425262728293031323334353637/** * Created by makersy on 2019 */public class SomeMethods &#123; @CheckException(description = "减法") public static void method1() &#123; System.out.println("1 - 1 = " + (1 - 1)); &#125; @CheckException(description = "加法") public static void method3() &#123; System.out.println("4 + 3 = " + (4 + 3)); &#125; @CheckException(description = "乘法") public static void method2() &#123; System.out.println("2 * 3 = " + (2 * 3)); &#125; @CheckException(description = "除法") public static void method4() &#123; System.out.println("5 / 0 = " + (5 / 0)); &#125;// @CheckException// public static void method5() &#123;// System.out.println("1 - 1 = " + (1 - 1));// &#125; //没有注解的类，在主方法中不会被调用到 public static void method6() &#123; System.out.println("no annotation"); &#125; &#125; 最后是测试类： 1234567891011121314151617181920212223242526/** * Created by makersy on 2019 */public class TestTool &#123; public static void main(String[] args) &#123; SomeMethods someMethods = new SomeMethods(); int cnt = 0; //异常计数 for (Method method : SomeMethods.class.getDeclaredMethods()) &#123; if (method.isAnnotationPresent(CheckException.class)) &#123; //判断注解是否为我们定义的那个 CheckException anno = method.getAnnotation(CheckException.class); //获取CheckException注解 System.out.println(anno.description() + ":"); //打印方法注解的描述 try &#123; method.invoke(someMethods, null); //调用方法 &#125; catch (IllegalAccessException | InvocationTargetException e) &#123; System.out.println(method.getName() + " has error. Caused By: " + e.getCause().getClass().getSimpleName()); System.out.println(e.getCause().getMessage()); cnt++; //异常计数+1 &#125; &#125; &#125; System.out.println(someMethods.getClass().getSimpleName() + " has " + cnt + " error!"); &#125;&#125; 下面是结果展示：]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP流量控制与拥塞控制原理分析]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2FTCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[TCP的流量控制使用滑动窗口进行流量控制所谓的流量控制，就是让发送方的发送速率不要太快，让接收方来得及接收。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。 如图说明了如何利用滑动窗口机制进行流量控制。 设主机A向主机B发送数据。假设B发送给A的rwnd (receiver window，窗口值) 是400，发送方的发送窗口不能超过接收方给出的接收窗口的数值。TCP的窗口单位是字节，不是报文段，请注意。 再设每一个报文段为100字节长，序号的初始值为seq=1。注意图中的大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值。 接收方的主机B进行了三次流量控制。第一次把窗口设置为rwnd=300，第二次减小到rwnd=100，最后减到rwnd=0，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。另外B向A发送的三个报文段都设置ACK=1，可以看出只有在ACK=1时确认号字段才有意义。 假如，B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd=400的报文段，然而这个报文段在传送中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。这样就死锁了。 为了解决这种死锁状态，TCP为每个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方重设持续计时器；如果窗口不是零，那么死锁就不会发生了。 注意：即使是零窗口，也必须接收这几个报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段。因此上述的零窗口探测报文段也是可以被接收到的。 TCP报文段发送时机的控制控制TCP报文的发送时机主要有以下几种机制。1）TCP维持一个变量，它等于最大报文段长度MSS，只要缓存中存放的数据达到MSS字节就组装成一个TCP报文段发送出去。2）由发送方的应用程序指明要求发送报文段，即TCP支持的推送(push)操作3）发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（长度不超过MSS）发送出去。 Nagle算法在TCP实现中广泛使用Nagle算法。算法是这样的：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，也就是说数据从进程到发送缓存是挤牙膏似的一点点的发送，那么就先把第一个字节发出去，等发送方收到对第一个数据字符的确认后，把数据积攒成一个大的数据块（报文段）发送出去，继续对随后到达的数据进行缓存。发送方每次只有收到接受方对前一个报文段的确认后才发送下一个报文段。 当数据到达较快而网络速率较慢时，用这样的方式可以明显的减少所用的网络带宽。 该算法还规定，当到达的数据已达到发送窗口大小的一般或已达到报文段的最大长度时，就立即发送一个报文段，这样做可以有效地提高网络的吞吐量。（吞吐量：单位时间从网络从网络输出的分组数目） 总体来说，目的是使得在发送方不发送很小的报文段的同时，接受方也不要在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息发送给对方。 TCP的拥塞控制拥塞控制的原理拥塞控制的产生在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变差，这种情况叫做拥塞。也就是说：$$\sum对资源的需求 &gt; 可用资源$$ 网络拥塞往往是由许多因素引起的，简单的提高节点处理机的运算速度，或者扩大结点缓存的存储空间，在很多时候并不能解决拥塞问题。例如1）当某个结点缓存容量扩展到非常大，于是凡到达该结点的分组均可在结点的缓存队列中排队，不受任何限制。由于输出链路的容量和处理机的速度并未提高，因此在这队列中的绝大多数的分组在排队等待时间会大大增加，结果上层软件只好把他们进行重传（因为已超时）。 因此，问题的实质往往是整个系统的各个部分不匹配，只有各个部分平衡了，问题才会得到解决。 拥塞控制和流量控制的不同所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。它是一个全局性的过程，涉及到所有的主机、所有的服务器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。 拥塞控制设计拥塞控制是很难设计的，因为它是一个动态的问题，许多情况下，甚至正是拥塞控制机制本身成为引起网络性能恶化甚至死锁的原因。从控制理论的角度来看拥塞控制这个问题，可以分为开环控制和闭环控制两种方法。开环控制就是在设计网络时事先将有关拥塞发生的所有因素考虑周到，一旦系统运行起来就不能在中途改正。闭环控制是基于反馈环路的概念，包括如下措施：1）监测网路系统以便检测拥塞在何时何地发生2）把拥塞发生的信息传送到可采取行动的地方3）调整网络系统的行动以解决出现的问题。 拥塞控制方法因特网建议标准RFC2581定义了进行拥塞控制的四种算法，即慢开始（Slow-start)、拥塞避免（Congestion Avoidance)、快重传（Fast Retransmit）和快恢复（Fast Recovery）。我们假定：1）数据是单方向传送，对方只传送确认报文。2）接收方总是有足够大的缓存空间，因而发送窗口的大小由网络的拥塞程度来决定。 1. 慢开始和拥塞避免发送报文段速率的确定，既要根据接收端的接收能力，又要从全局考虑不要使网络发生拥塞，这由接收窗口和拥塞窗口两个状态量确定。接收端窗口（Reciver Window)又称通知窗口（Advertised Window)，是接收端根据目前的接收缓存大小所许诺的最新窗口值，是来自接收端的流量控制。拥塞窗口 cwnd（Congestion Window）由发送端维持，是发送端根据自己估计的网络拥塞程度而设置的窗口值（发送窗口=拥塞窗口），是来自发送端的流量控制。 慢开始算法：1）当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引起网络拥塞2）比较好的方法是试探一下，即从小到达逐渐增大发送窗口，也就是由小到大逐渐增大拥塞控制窗口。可以这么理解，每经过一个传输轮次，拥塞窗口cwnd就加倍。一个传输轮次意思是：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。由此可以看出：慢开始算法的拥塞窗口的增长速度是指数级的。3）通常在刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段的MSS的数值。在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值，当rwind足够大的时候，为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量–慢开始门限ssthresh用法： cwnd &lt; ssthresh 时，使用慢开始算法；cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法；cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。 拥塞避免算法：1）TCP连接初始化，将拥塞窗口设置为12）执行慢开始算法，cwind按指数规律增长，直到cwind == ssthress开始执行拥塞避免算法，cwnd按线性规律增长3）当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤（2）执行。 2. 快重传和快恢复一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。 快重传算法首先要说明快重传算法的目的是让发送方尽早知道发生了个别报文段的丢失。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认。即使收到了失序的报文段也要立即发出对已经收到的报文段的重复确认。如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时。 慢开始算法只是在TCP建立时才使用。 快恢复算法1）当发送方连续收到三个重复ACK时，就执行 “乘法减小” 算法，把慢开始门限设置为拥塞窗口的一半，这是为了预防网络发生拥塞2）由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把cwnd值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法，拥塞窗口线性增大。 由此总结：在拥塞避免阶段，拥塞窗口是按照线性规律增大的，这常称为加法增大AI(Additice Increase)。而一旦出现超时或3个重复的确认，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值，这常称为“乘法减小”MD(Multiplication Decrease)。二者合在一起就是所谓的AIMD算法。 题外话：在我看到快恢复算法的时候，产生了这样一个疑问：仅仅是丢失了一个报文段，为什么需要降低门限值、拥塞窗口值，而不是按照当前的进度、速度继续传呢？ 经过反复看书思考，我得出的结论是：丢失了一个报文段意味着即将发生拥塞，但是当前还没有拥塞。为了避免发送方错误地开启慢开始算法，拥塞窗口cwnd的值又设置为1，进而降低传输效率，于是采用快恢复算法调整门限值，使用拥塞避免算法来尽可能规避拥塞，达到兼顾效率和拥塞控制的目的。不知道想的对不对。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输控制协议TCP概述]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[最近在看《计算机网络》这本书，感觉写的挺好的。现在学到了TCP部分，我对TCP部分做了笔记，记录了一些重点，也记录了一些自己的想法，在此分享。 TCP最主要的特点 TCP是面向连接的运输层协议。 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。 TCP提供可靠交付的服务。无差错、不丢失、不重复，并且按序到达。 TCP提供全双工通信。TCP允许双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。 TCP是面向字节流的。这点不像UDP那样面向报文，对应用层交下来的报文 “既不合并，也不拆分” 。TCP只是把它们都看作是一连串无结构的字节流，并不了解所传送的字节流的含义，接收时的数据块跟发送时数据块数量可能不一样，但是总数据不会缺失。例如可能发送方应用程序交个发送方TCP有10个数据块，但接收方TCP可能只用了5个数据块就把收到的字节流交付上层的应用程序，虽然总共的字节流是一样的。将字节流还原成有意义的数据的任务，就交给应用层来完成。 套接字socketTCP把连接作为最基本的抽象。 TCP连接的端点叫做套接字(socket)或插口。根据RFC 793的定义：端口号拼接到IP地址即构成了套接字。因此，套接字的表示方法是在点分十进制的IP地址后面写上端口号，中间用冒号或逗号隔开。即： 套接字socket = (IP地址 : 端口号) 每一条TCP连接唯一的被通信两端的两个端点（即两个套接字）所确定。即： TCP连接 ::= {socket1, socket2} = {IP1:port1}, {IP2:port2} 需要注意的是，同一个名词socket可能有不同的意思，此处的socket仅仅是TCP连接的端点。 TCP报文段的首部格式如图为TCP报文段的首部格式。 首部固定部分各字段意义如下： 1）源端口和目的端口各占2个字节，分别写入源端口和目的端口。 2） 序号占4字节。序号范围是[0，232 - 1]，共232（即4294967296）个序号。序号增加到232-1后，下一个序号就又回到0。也就是说，序号使用mod 232运算。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是301，而接待的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。 3） 确认号占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。 总之：若确认号 = N，则表明：到序号N-1为止的所有数据都已正确收到。 4） 数据偏移占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。 5） 保留占6位，保留为今后使用，但目前应置为0 。下面有6个控制位，用来说明本报文段的性质。 6） 紧急URG（URGent）当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。 当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。 7） 确认ACK（ACKnowledgment）仅当ACK = 1时确认号字段才有效，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。 8） 推送 PSH（PuSH）当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付。 9） 复位RST（ReSeT）当RST=1时，表名TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。 10） 同步SYN（SYNchronization）在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。 11） 终止FIN（FINis，意思是“完”、“终”）用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。 12） 窗口占2字节。窗口值是[0，216-1]之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值被视为接收方让发送方设置其发送窗口的依据。 例如，发送了一个报文段，其确认号是701，窗口字段是1000.这就是告诉对方：“从701算起，我（即发送方报文段的一方）的接收缓存空间还可接受1000个字节数据（字节序号是701~1700），你在给我发数据时，必须考虑到这一点。” 总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。 13） 检验和占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6,则相应的伪首部也要改变。 14） 紧急指针占2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据） 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。 15） 选项长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节。 TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Size）。注意MSS这个名词含义。MSS是每一个 TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。 为什么要规定一个最大报文长度MSS呢？这并不是考虑接受方的接收缓存可能存放不下TCP报文段中的数据。实际上，MSS与接收窗口值没有关系。我们知道，TCP报文段的数据部分，至少要加上40字节的首部（TCP首部20字节和IP首部20字节，这里还没有考虑首部中的可选部分）才能组装成一个IP数据报。若选择较小的MSS长度，网络的利用率就降低。设想在极端情况下，当TCP报文段只含有1字节的数据时，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销。但反过来，若TCP报文段非常长，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片组成成原来的TCP报文段，当传输出错时还要进行重传，这些也都会使开销增大。 因此，MSS应尽可能大些，只要在IP层传输时不需要分片就行。由于IP数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要的分片的MSS，如果改走另一条路径就可能需要进行分片。因此最佳的MSS是很难确定的。在连接过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传输数据，两个传送方向可以有不同的MSS值。若主机未填写这一项，则MSS的默认值是536字节长。因此，所有在互联网上的主机都应该接受的报文段长度是536+20（固定首部长度）=556字节。 后来又增加了几个选项如窗口扩大选项、时间戳选项、选择确认选项等。 窗口扩大选项是为了扩大窗口。我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。 窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2(16+14)-1=230-1。窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S=0选项，使窗口大小回到16。 时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个概念： 第一、 用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。 第二、 用于处理TCP序号超过 232 的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加 232个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。例如，当使用1.5Mbit/s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit/s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。 可靠传输的工作原理TCP发送的报文段是交给IP层传送的，但IP层只能提供尽最大努力交付，也就是说，TCP下面的网络提供的是不可靠的传输。因此TCP必须采取适当的措施才能使得两个运输层之间的通信变得可靠。为此就有下面的协议。 停止等待协议 无差错情况 A发送分组给B，发完暂停发送，等待B的确认。B收到了就向A发送确认，A在收到了B的确认后，就再发送下一个分组。 出现差错情况 B在接收时出了差错，就丢弃掉出错部分，或许分组在传输中丢失掉了，这时B不会发送任何信息。可靠传输协议设计为：A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢了，因而重传前面发送过的分组。这叫做超时重传。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。 应注意： A在发送完一个分组后，必须暂时保留已发送分组的副本（在发生超时重传时使用）。只有在收到相应的确认后才能清楚暂时保留的分组副本； 分组和确认分组必须编号。如此才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认； 超时计数器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。 确认丢失和确认迟到 确认丢失A在设定的超时重传时间内没有收到确认，并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了。因此A在超时计时器到期后就要重传分组。此时B又收到了A发来的重复分组，这时应采取两个行动：第一，丢弃这个重复的分组，不用向上交付；第二，向A发送确认。 确认迟到B对分组的确认迟到了，A会收到重复的确认，对重复的确认的处理是：收下后就丢弃。B同样要丢弃重复的分组，并重传确认分组。 A最终总会收到对所有发出的分组的确认。如果A不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。 向上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。像上述的这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat Request)。意思是重传的请求是自动进行的。接受方不需要请求发送方重传某个出错的分组。 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断的传送。 当使用流水线传输，就要使用下面的连续ARQ协议和滑动窗口协议。 连续ARQ协议发送方维持一个发送窗口，一次把窗口内所有分组全部发送出去，不必收到确认后再发送下一个。每收到一个确认，发送窗口就往前移动一个分组。 接受方一般是累计确认的方式。在收到几个分组后，对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已经正确收到了。 累计确认的优点是：容易实现，即使确认丢失也不用重传； 缺点是：不能向发送方反映出接收方已经正确接收到的所有分组的信息。例如，如果一共发送了5个分组，由于某些原因第3个分组丢失了，这时接收方只能发送到第2个分组的确认信息，发送方无法得知后三个分组是否送达，于是只好把这三个重传一次，称为 Go-back-N（回退N）。可见当通信质量不好的时候，会出现重传很多次的情况，带来不好的影响。 滑动窗口协议TCP的滑动窗口协议以字节为单位。若假定A收到了B发来的确认报文段，其中窗口是20字节，确认号是31（这表明B期望收到的下一个序号为31，而序号30为止的数据已经收到了）。根据这两个数据，A构造出自己的发送窗口，即从31到50的窗口。 发送窗口是什么？它表示，在未收到B的确认的情况下，A可以连续把窗口内的数据发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。 假设缓存窗口序号是从左到右依次增大的，那么左边设为窗口后沿，右边为窗口前沿，那么窗口后沿后边的部分表示已发送且已确认，前沿前边的部分表示不允许发送，因为接受方窗口不包括这里，没有生成对此的缓存。 发送窗口的位置由窗口前沿和后沿共同确认。其后沿变化有两种情况，即不动（没有收到新的确认）和前移（收到了新的确认）。后沿不可能向后端移动，因为后沿之后的数据均已经被确认过了。前沿一般是不断向前移动的，但也有可能不动，比如：一种是没有收到新的确认，对方通知的窗口大小不变；第二种是收到了新的确认，同时对方通知的窗口也缩小了，恰好保持前沿不动。前沿也有可能向后收缩（对方通知的窗口缩小了），但是TCP标准不推荐这么做，前面发送过，再进行取消，会产生一些错误。 发送窗口始终进行“发送-接收确认-调整窗口-发送“的过程。但是存在一些特殊情况，如：A发送窗口所有数据都发送给了B，B也返回了确认，但是所有确认都滞留在网络中。A没有收到确认一段时间后，就只好重传这些数据，即超时重传，直到收到B的确认为止。 TCP的流量控制与拥塞控制可以参考我的另一篇文章：TCP流量控制与拥塞控制原理分析 TCP的连接与连接释放可以参考我的另一篇文章：TCP知识点总结]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TCP的学习总结]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2FTCP%E3%80%81UDP%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、TCP和UDP的区别（1）TCP面向连接，UDP无连接；（2）TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证；（3）TCP传输速度慢；UDP速度快（4）每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信（5）TCP对系统资源要求较多，UDP对系统资源要求较少。（6）TCP的逻辑通信信道是全双工的可靠信道，UDP是不可靠信道。（7）UDP没有拥塞机制，因此网络出现拥塞不会使源主机的发送速率降低。（8）TCP首部开销20字节；UDP的首部开销小，只有8个字节；（9）UDP面向报文。 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP； FlashFXP，用的FTP； Outlook，用的POP、SMTP； Putty，用的Telnet、SSH； QQ文件传输 … 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频…有些应用场景对可靠性要求不高会用到UDP，比如长视频，要求速率 2、TCP三次握手四次挥手2.1 建立连接协议（三次握手）（1）客户端发送一个带SYN标志位、seq的TCP报文到server。这是三次握手过程中的报文1。此时client进入SYN_SEND状态。（2） server端回应client的报文，是三次握手中的第2个报文。这个报文同时带ACK（确认字符）标志、SYN标志、ack（=收到来自客户端的seq+1）、seq（server自己的）。因此它表示对刚才client SYN报文的回应。此时server进入SYN_RECV状态。（3） 客户必须再次回应服务段一个包括ACK、ack（=来自server的seq+1）、seq（第一次握手的seq+1）的报文，这是报文段3。此时双方进入ESTABLISHED状态。名词解释： 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 SYN：属于一个标志位，为1时代表这是一个连接请求（当ACK=0）或连接接受响应（当ACK=1）报文；SYN这个标志位只有在TCP建立连接时才会被置1，握手完成后SYN标志位被置0。 ACK：只在响应中出现。占1位，仅当ACK=1时，ack才有效。ACK=0时，ack无效。 2.2 连接终止协议（四次挥手）因为TCP连接是全双工的，因此每一个方向都必须单独进行关闭。这原则是当一方完毕它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN仅仅意味着这一方向上没有数据流动。一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将运行主动关闭。而还有一方运行被动关闭。流程： （1） 主机1发送FIN和seq。请求关闭主机1到主机2的数据传送（报文段4）。此时状态变化： 1：FIN_WAIT1 （2） 主机2收到这个FIN。它发回一个ACK、ack（收到的seq加1）、seq（报文段5）。这一步代表主机2同意关闭连接，但连接并没有关闭，因为主机2可能还有数据没发完，为此需要等待。此时状态变化：2：CLOSE_WAIT | 1：FIN_WAIT2 （3） 主机2发完剩余数据，准备关闭与主机1的连接，并发送一个FIN给主机1（报文段6）。进入LAST-ACK（最后确认）状态。如果没收到主机1的回复，会进行超时重传的。 （4） 主机1收到主机2回复，知道它的数据发送完了。于是发回ACK报文确认收到，告诉主机2你可以关了。并将ack设置为收到序号加1（报文段7）。这样一来主机2收到后就安心关闭连接了。此时状态变化： 1：TIME_WAIT | 2：CLOSED。 这样四次挥手就完成了。不过别忘了，主机1还在TIME_WAIT状态。他需要等待2MSL的时间，如果在这段时间又收到来自主机2的FIN+ACK报文（报文段6），就会再发送ACK报文回去，直至过了2MSL且再无回音，就关掉。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指任何IP数据报能够在因特网上存活的最长时间，2MSL就是一个发送和一个回复所需的最大时间。 名词解释： FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 3. 一些常见的问题 为什么要进行time wait，为什么要等2MSL？为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。没收到确认的话，B是会超时重传这个FIN+ACK报文段的，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态。 为什么连接的时候是三次握手，关闭的时候却是四次握手？因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，可能还有数据要传，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，是不能一起发送的。故需要四步握手。 为什么要三次握手？不行。因为握手是为了确认双方收发功能均正常，进而确认可以同步序列号。第一次client -&gt; server，server可以确认client发是好的；第二次server -&gt; client，client可以确认自己收发是好的，对方收发也是好的；第三次client -&gt; server，server可以确认自己收发是好的，对方也是。为什么可以这么确认？是因为这收发之间都存在着校验。第一次server收到client的连接请求，推测其可能要发起连接，于是按规定返回了client要求的ack（收到的seq+1），并且发了自己的seq，看对方是不是真想连接；第三次client收到并返回的过程类似第二步。如此，就完成了对接。为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议基础]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2FHTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写。HTTP协议工作于客户端-服务端架构之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器在接收到的请求后，向客户端发送响应信息。 HTTP特点 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。 灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。常用的请求方法 GET: 向指定的资源请求数据。 POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和或已有资源的修改。 HEAD: 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 PUT: 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE: 请求服务器删除指定的页面。 post和get的区别：都包含请求头请求行，post相比之下多了请求body。get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。 报文构成请求报文构成http请求由请求行（request line）、请求头部（header）、空行和请求数据构成。请求行以请求方法开头，后面跟着请求的URL和协议的版本，均以空格分开。 响应报文构成HTTP响应也由状态行、消息报头、空行和响应正文构成。 状态码响应状态码：访问一个网页时，浏览器会向web服务器发出请求。此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求。 状态码分类以下是状态码的分类。123451XX- 信息型，服务器收到请求，需要请求者继续操作。2XX- 成功型，请求成功收到，理解并处理。3XX - 重定向，需要进一步的操作以完成请求。4XX - 客户端错误，请求包含语法错误或无法完成请求。5XX - 服务器错误，服务器在处理请求的过程中发生了错误。 常见状态码12345678200 - OK 客户端请求成功301 - 资源（网页等）被永久转移到其它URL302 - 临时跳转400 Bad Request - 客户端请求有语法错误，不能被服务器所理解401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用404 - 请求资源不存在，可能是输入了错误的URL500 - 服务器内部发生了不可预期的错误503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 客户端浏览器如何解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;2、解析出 IP 地址后，若有端口号则解析出端口号，无则根据该 IP 地址和默认端口 80，和服务器建立TCP连接;3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;5、释放 TCP连接;6、浏览器将该 html 文本并显示内容。 几个概念DNS域名解析服务。将主机名转换为IP地址。端口号http://localhost:8080 8080就是端口号。HTTP的URL中没有端口号时，可以假设默认端口号时80。有了IP地址和端口号，客户端就可以很方便地通过TCP/IP进行通信了。代理代理是位于客户端和服务器之间的HTTP中间实体。接收所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。缓存缓存HTTP的仓库，使常用页面的副本可以保存在离客户端更近的地方。隧道隧道是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。常见用途是通过HTTP连接承载加密的安全套接字层（SSL）流量，这样SSL流量就可以穿过只允许Web流量通过的防火墙了。 HTTP和HTTPS的区别HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。HTTPS和HTTP的区别主要如下：1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 参考文章：https://blog.csdn.net/weixin_41835916/article/details/81590826]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见七大排序的Java实现]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0(%E6%8F%92%E5%85%A5%2B%E5%B8%8C%E5%B0%94%2B%E5%86%92%E6%B3%A1%2B%E5%BF%AB%E9%80%9F%2B%E9%80%89%E6%8B%A9%2B%E5%BD%92%E5%B9%B6)%2F</url>
    <content type="text"><![CDATA[之前学习C语言时学过各类基础排序，现在用Java来再回顾一遍。这一篇主要是写一下规范的代码。 一、排序相关的基本概念 排序其实是一个相当大的概念，主要分为两类：内部排序和外部排序。而我们通常所说的各种排序算法其实指的是内部排序算法。内部排序是基于内存的，整个排序过程都是在内存中完成的，而外部排序指的是由于数据量太大，内存不能完全容纳，排序的时候需要借助外存才能完成（常常是某一部分已经计算过的数据移出内存让另一部分未被计算的数据进入内存）。而本篇文章将主要介绍内部排序中的几种常用排序算法：为了测试方便，我定义了生成随机数组的Const类和打印输出的print函数。Const类如下： 12345678910public class Const &#123; public int a[] = new int[50]; public Const()&#123; Random random = new Random(); for( int i=0; i&lt;a.length; i++ )&#123; a[i] = random.nextInt(100); &#125; &#125;&#125; 二、插入类排序1.直接插入插入类排序算法的核心思想是，在一个有序的集合中，我们将当前值插入到适合位置上，使得插入结束之后整个集合依然是有序的。代码如下：123456789101112131415161718/** * 插入排序 * @param array */ public static void InsertSort(int[] array)&#123; int i, j, key; for( i=1; i&lt;array.length; i++ )&#123; key = array[i]; j = i - 1; //取当前位置值，与已经排序好的那一部分由大到小进行比较，将其挪到正确的位置 while ( j&gt;=0 &amp;&amp; key&lt;array[j] )&#123; array[j+1] = array[j]; j--; &#125; array[j+1] = key;//在正确的位置插入key值 &#125; print(array); &#125; 2、二分插入原理是二分查找到合适位置再进行插入。1234567891011121314151617181920212223242526272829/** * 二分插入排序 * @param array */ public static void halfInsertSort(int[] array)&#123; for( int i=1; i&lt;array.length; i++ )&#123; int mid, low, high, key; low = 0; high = i-1; key = array[i]; //这个循环之后，要插入的地方为low while ( low&lt;=high )&#123; mid = (low+high)/2; if( key==array[mid] )&#123; low = mid; break; &#125;else if( key&gt;array[mid] )&#123; low = mid + 1; &#125;else&#123; high = mid - 1; &#125; &#125; //将已排序部分low之后的都向后移动一位 for( int k=i-1; k&gt;=low; k-- )&#123; array[k+1] = array[k]; &#125; array[low] = key; &#125; print(array); &#125; 3、希尔排序希尔排序算法使用一个距离增量来切分子序列，使每个子序列都有序。当距离增量变小的时候，序列的个数也会变少，但是这些子序列的内部都基本有序，当对他们进行直接插入排序的时候会使得效率变高。一旦距离增量减少为1，那么子序列的个数也将减少为1，也就是我们的原序列，而此时的序列内部基本有序，最后执行一次直接插入排序完成整个排序操作。12345678910111213141516171819202122/** * 希尔排序 * @param array */ public static void shellSort(int[] array)&#123; int len = array.length; int step = len/2;//步长 while( step&gt;0 )&#123; for( int i=step; i&lt;len; i++ )&#123; int j = i; //while循环 --对由步长分成的各数组进行直接插入排序 while ( j&gt;=step &amp;&amp; array[j]&lt;array[j-step] )&#123; int temp = array[j]; array[j] = array[j-step]; array[j-step] = temp; j -= step; &#125; &#125; step /= 2; &#125; print(array); &#125; 三、交换类排序1、冒泡排序冒泡排序通过两两比较，每次将最大或者最小的元素移动到整个序列的一端。123456789101112131415161718/** * 冒泡排序 * @param array */ public static void bubbleSort(int[] array)&#123; int temp = 0; //每次将最大的放到最后，需要进行length-1次 for( int i=0; i&lt;array.length-1; i++ )&#123; for( int j=1; j&lt;array.length-1-i; j++ )&#123; if( array[j]&lt;array[j-1] )&#123; temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; &#125; &#125; &#125; print(array); &#125; 2、快速排序快速排序的基本思想是，从序列中任选一个元素，但通常会直接选择序列的第一个元素作为一个标准，所有比该元素值小的元素全部移动到他的左边，比他大的都移动到他的右边。该排序算法是目前为止，内部排序中效率最高的排序算法。12345678910111213141516171819202122232425262728293031323334/** * 快速排序 * @param array */ public static void quickSort(int[] array)&#123; int low = 0; int high = array.length-1; qSort(array, low, high); print(array); &#125; private static void qSort(int[] array, int low, int high)&#123; if( low&lt;high )&#123; int pos = oneQuickSort(array, low, high); qSort(array, low, pos-1); qSort(array, pos+1, high); &#125; &#125; private static int oneQuickSort(int[] array, int low, int high)&#123; int key = array[low]; while ( low&lt;high )&#123; while ( low&lt;high &amp;&amp; array[high]&gt;=key )&#123; high--; &#125; array[low] = array[high]; while ( low&lt;high &amp;&amp; array[low]&lt;=key )&#123; low++; &#125; array[high] = array[low]; &#125; array[low] = key; return low; &#125; 四、选择类排序选择类排序的基本思想是，每一趟会在n个元素中比较n-1次，选择出最大或者最小的一个元素放在整个序列的端点处。1234567891011121314151617181920/** * 直接选择排序 * @param array */ public static void selectionSort(int[] array)&#123; for( int i=0; i&lt;array.length; i++ )&#123; int minIdx = i; //记录最小值的位置 for( int j=i+1; j&lt;array.length; j++ )&#123; if( array[j]&lt;array[minIdx] )&#123; minIdx = j; &#125; &#125; if( minIdx!=i )&#123; int temp = array[i]; array[i] = array[minIdx]; array[minIdx] = temp; &#125; &#125; print(array); &#125; 五、归并类排序算法1234567891011121314151617181920212223242526272829303132333435363738/** * 归并排序 * @param array */ public static void mergeSort(int[] array)&#123; int len = array.length; int[] arrayTemp = new int[len]; mSort(array, 0, len-1, arrayTemp); print(array); &#125; private static void mSort(int[] array, int low, int high, int[] arrayTemp)&#123; if( low &lt; high ) &#123; int mid = low + (high-low)/2; //分界 mSort(array, low, mid, arrayTemp); mSort(array, mid+1, high, arrayTemp); mergeTwoArray(array, low, mid, high, arrayTemp); &#125; &#125; private static void mergeTwoArray(int[] array, int low, int mid, int high, int[] arrayTemp)&#123; int i=low, j=mid+1; int current = 0; while ( i&lt;=mid &amp;&amp; j&lt;=high )&#123; if( array[i]&lt;array[j] )&#123; arrayTemp[current++] = array[i++]; &#125;else&#123; arrayTemp[current++] = array[j++]; &#125; &#125; while( i&lt;=mid )&#123; arrayTemp[current++] = array[i++]; &#125; while ( j&lt;=high )&#123; arrayTemp[current++] = array[j++]; &#125; System.arraycopy(arrayTemp,0,array,low,current); &#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery和ajax使用.md]]></title>
    <url>%2Funcategorized%2FjQuery%E5%92%8Cajax%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JSP FileUpload实现文件上传]]></title>
    <url>%2FJava%2FWeb%2FJSP-FileUpload%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[文件上传的条件 表单必须是post提交方式 表单中必须有文件上传项，文件上传项必须有name属性和值 表单的enctype属性必须设置为multipart/form-data 文件上传基本操作数据接收：通过使用fileupload jar包的Common-FileUpload组件完成文件上传基本步骤： 创建一个 磁盘文件项工厂 的对象DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory(); 创建一个核心解析类ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory ); 解析request请求 —— parseRequest，返回一个List集合，List集合中存放的是FileItem对象（每一个表单项都是一个FileItem对象）List&lt;FileItem&gt; list = servletFileUpload.parseRequest(request); 遍历集合，获得每个FileItem，判断是表单项还是文件上传项fileItem.isFormField(): 返回是普通的文件表单项还是文件上传项fileItem.getFieldName(): 获得表单项的name属性值fileItem.getString(“UTF-8”): 获取表单的文本值，可设置UTF-8解决中文乱码 获得文件名：String filename = fileItem.getName(); 通过自定义工具类获得唯一文件名：String uuidfilename = UploadUtils.getUUIDFileName(filename);注：UploadUtils类是自定义工具类，具体实现是： 123456789101112131415public class UploadUtils &#123; /* * 生成唯一文件名 * */ public static String getUUIDFileName(String fileName) &#123; int idx = fileName.lastIndexOf("."); String extention = fileName.substring(idx);//扩展名 String uuidFileName = UUID.randomUUID().toString().replace("-", "")+extention; return uuidFileName; &#125; public static void main(String[] args) &#123; System.out.println(getUUIDFileName("1.jpg")); &#125;&#125; 输入流获得文件上传的数据：InputStream is = fileItem.getInputStream(); 得到文件要上传的路径url = this.getServletContext().getRealPath(&quot;/upload&quot;)+&quot;//&quot;+uuidfilename; 输入流对接输出流123456789OutputStream os = new FileOutStream(url);//输出流目标为urlint len = 0;byte[] b = new byte[1024];while((len=is.read(b)) != -1)&#123;//读取输入流到b中os.write(b,0,len);//将b写入输出流中&#125;is.close();//关闭输入流os.close();//关闭输出流&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0050 Pow(x,n)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2FLeetCode%200050%20Pow(x%2Cn)%2F</url>
    <content type="text"><![CDATA[题目实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 输入: 2.00000, 10输出: 1024.00000 示例 2: 输入: 2.10000, 3输出: 9.26100 示例 3: 输入: 2.00000, -2输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 题解用的递归法，log n123456789101112131415161718192021222324252627class Solution &#123; public double myPow(double x, int n) &#123; boolean isNagetive = false; if( n&lt;0 ) &#123; n = -n; isNagetive = true; &#125; if( isNagetive ) &#123; return 1/pow(x, n); &#125;else &#123; return pow(x, n); &#125; &#125; public static double pow(double x, int n) &#123; double res = 1.0; if( n==0 ) &#123; return 1.0; &#125;else if( n==1 ) &#123; return x; &#125;else if( n%2==0 ) &#123; res = pow(x*x, n/2); &#125;else&#123; res = pow(x*x, n/2) * x; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0109 有序链表转换二叉搜索树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FLeetCode%200109%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。示例： 给定的有序链表： [-10, -3, 0, 5, 9], 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：123456&gt; 0&gt; / \&gt; -3 9&gt; / /&gt; -10 5&gt; 题解这道题类似归并排序，需要每次都把链表分为尽可能等长的两部分，然后分别对这两部分再进行生成二叉树的操作。可以用快慢指针，具体实现是：设置快慢指针各一个，慢指针步进为1，快指针步进为2，循环条件是快指针不为空且其子节点不为空。这样快指针走的长度是慢的2倍，可以保证每次循环都找到了链表的中心节点（平衡二叉树需要找中心节点）。每次循环后链表被分为： 0-premid、slow、slow.next-最后一个 这三部分。Java代码如下：123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if( head==null ) return null; if( head.next==null ) return new TreeNode(head.val); ListNode slow = head; ListNode fast = head; ListNode premid = null; while( fast!=null &amp;&amp; fast.next!=null ) &#123; premid = slow; slow = slow.next; fast = fast.next.next; &#125; premid.next = null; TreeNode root = new TreeNode(slow.val); root.left = sortedListToBST(head); root.right = sortedListToBST(slow.next); return root; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse建立web项目时忘了生成xml文件的解决办法]]></title>
    <url>%2F%E5%8F%91%E7%8E%B0%2Feclipse%E5%BB%BA%E7%AB%8Bweb%E9%A1%B9%E7%9B%AE%E6%97%B6%E5%BF%98%E4%BA%86%E7%94%9F%E6%88%90xml%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[刚学web没多久，建立项目时忘了去勾选建立web.xml文件的选项。当我写了好多代码，接下来需要修改这个文件的时候才发现，我没有生成它…接下来在摸索中找到了解决办法。首先在创建的项目上右键，找到Java EE Tools，然后点击Generate Deployment Descriptor Stub，如下图（我的已经生成了所以是灰色）。完了之后会发现，web.xml躺在WEB-INF文件夹下~ （完）]]></content>
      <categories>
        <category>发现</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-EL表达式和JSTL标签库]]></title>
    <url>%2FJava%2FWeb%2FJava-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CJSTL%E6%A0%87%E7%AD%BE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[关于EL表达式EL表达式全名为Expression Language，是一种为了在JSP中计算和输出Java对象的简单语言。基本语法： ${expression}以上语句中，expression为有效的表达式。该表达式可以和静态文本混合，还可以与其他表达式结合成为更大的表达式。 EL四个作用域对象如果我们在jsp页面调用Servlet的数据信息时，不写这个范围，那么EL就会从在小到大的范围内依次去寻找我们调用的这些数据。（因此最好写上） EL表达式输出语法：${[作用域.]属性名[.子属性]}EL支持绝大多数对象输出，本质是执行toString方法例： ${title}${requestScope.student.name}${emp.salary + 300}${ 1&lt;=3 &amp;&amp; 2&gt;4 } 获取数据：我们可以使用EL的内置对象param来简化获取url或者请求体中的数据语法：${param.参数名}例如当url是 https://class.makersy.com/lesson?mid=17331在Servlet中，我们用request.getParameter(“mid”)获取而现在可以用${param.mid}获取了其实，${param.参数名}就是request.getParameter（“参数名”);的简化形式 JSTL标签库使用JSTL表达式JSTL是JSP标准标签库的简称，它提供的标签能一定程度上代替Java代码，例如&lt;c:forEach/&gt;标签能实现Java语言中的循环功能。 使用前：1.下载jstl.jar和standard.jar包 2将这两个包复制到web-inf\lib 目录下 3.在JSP页面中添加指令，例如： 核心标签库初始化&lt;%@ taglib uri = &quot;http://java.sun.com/jsp/jstl/core&quot; prefix = &quot;c&quot; %&gt;或格式标签库初始化&lt;%@ taglib uri = &quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix = &quot;fmt&quot; %&gt; JSTL标签库JSTL有五个标签库，分别是：核心标签库、格式标签库、函数标签库、SQL标签库、XML标签库。主要用前两者。 核心标签库主要完成JSP页面常用功能，包括JSTL表达式标签、URL标签、流程控制标签和循环标签等。其中，表达式标签有 和显示操作有关的&lt;c:out value=&quot; ${ news.title }&quot;/&gt;输出属性的值 数据库中给出的标签可以显示；&lt;c:set var=&quot;uid&quot; value=&quot;admin&quot; scope=&quot;request&quot;/&gt; 存入变量,把uid的变量存入request中;&lt;c:remove var=&quot;uid&quot; value=&quot;admin&quot; scope=&quot;request&quot;/&gt;移除变量 把request中的uid的变量移除. 实现程序逻辑相关的c:foreach标签&lt;c:forEach var=&quot;对象&quot; items=”保存在request中的数组&quot; varStatus=&quot;status&quot;&gt;循环的的变量&lt;c:forEach /&gt;&lt;c:forEach&gt;标签具有以下一些属性： var：迭代参数的名称。在迭代体中可以使用的变量的名称，用来表示每一个迭代变量。类型为String。 items：要进行迭代的集合。对于它所支持的类型将在下面进行讲解。 varStatus：迭代变量的名称，用来表示迭代的状态，可以访问到迭代自身的信息。 begin：如果指定了items，那么迭代就从items[begin]开始进行迭代；如果没有指定items，那么就从begin开始迭代。它的类型为整数。 end：如果指定了items，那么就在items[end]结束迭代；如果没有指定items，那么就在end结束迭代。它的类型也为整数。 step：迭代的步长。 &lt;c:forEach&gt;标签的items属性支持Java平台所提供的所有标准集合类型。此外，您可以使用该操作来迭代数组（包括基本类型数组）中的元素。它所支持的集合类型以及迭代的元素如下所示：​ java.util.Collection：调用iterator()来获得的元素。 java.util.Map：通过java.util.Map.Entry所获得的实例。​ java.util.Iterator：迭代器元素。​ java.util.Enumeration：枚举元素。​ Object实例数组：数组元素。​ 基本类型值数组：经过包装的数组元素。​ 用逗号定界的String：分割后的子字符串。​ javax.servlet.jsp.jstl.sql.Result：SQL查询所获得的行。​ 不论是对整数还是对集合进行迭代， &lt;c:forEach&gt;的varStatus属性所起的作用相同。和var属性一样，varStatus用于创建限定了作用域的变量（改变量只在当前标签体内起作用）。不过，由varStatus属性命名的变量并不存储当前索引值或当前元素，而是赋予javax.servlet.jsp.jstl.core.LoopTagStatus类的实例。该类包含了一系列的特性，它们描述了迭代的当前状态，如下这些属性的含义如下所示：​ current：当前这次迭代的（集合中的）项。​ index：当前这次迭代从0开始的迭代索引。​ count：当前这次迭代从1开始的迭代计数。​ first：用来表明当前这轮迭代是否为第一次迭代，该属性为boolean类型。​ last：用来表明当前这轮迭代是否为最后一次迭代，该属性为boolean类型。​ begin：begin属性的值。​ end：end属性的值​ step：step属性的值​下面是一个使用的小例子，判断x的值并输出他所在的区间。123456789101112131415161718192021222324&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%request.setAttribute("x", "11");%&gt;&lt;c:choose&gt;&lt;c:when test="$&#123;x&gt;0 &amp;&amp; x&lt;=10 &#125;"&gt;&lt;h1 style="color:blue"&gt;1-10之间的整数&lt;/h1&gt;&lt;/c:when&gt;&lt;c:when test="$&#123;x&gt;10 &amp;&amp; x&lt;=20 &#125;"&gt;&lt;h1 style="color:lightcoral"&gt;11-20之间的整数&lt;/h1&gt;&lt;/c:when&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; 格式化日期1234567891011121314151617181920212223242526272829303132333435jstl日期格式化代码&lt;%@page import="java.util.Date"%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%request.setAttribute("amt", "1898923.234");request.setAttribute("now", new Date());request.setAttribute("html", "&lt;a href='index.html'&gt;index&lt;/a&gt;");request.setAttribute("nothing", null);%&gt;&lt;!-- formatDate pattternyyyy - 四位年MM = 两位月dd = 两位日HH - 24小时制hh - 12小时制mm - 分钟ss - 秒数SSS - 毫秒--&gt;&lt;h2&gt;&lt;fmt:formatDate value="$&#123;requestScope.now &#125;" pattern="yyyy年MM月dd日HH时mm分ss秒SSS毫秒" /&gt; &lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>EL表达式</tag>
        <tag>JSTL标签库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Servlet和JSP]]></title>
    <url>%2FJava%2FWeb%2F%E5%85%B3%E4%BA%8EServlet%2F</url>
    <content type="text"><![CDATA[请求转发和响应重定向 请求转发： 是服务器跳转，只产生一次请求request.getRequestDispatcher(url).forward(request,response） 响应重定向： 是浏览器端跳转，会产生两次请求地址栏会变成最后的url （处理完成第一个请求之后返回一个特殊的响应给浏览器由浏览器重新发起另一个请求到新的资源）response.sendRedirect(url);HTTP状态码打开网页可根据出现的状态码来判断处于什么状态。 ContentType的作用ContentType决定浏览器采用何种方式对相应体进行处理 CookieCookie是浏览器保存在本地的文本内容Cookie常用于保存登录状态、用户资料等小文本Cookie具有时效性，Cookie内容会伴随请求发送给Tomcat1234567891011121314151617181920212223242526272829//Cookie部分doGet函数protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("用户登录成功！"); Cookie cookie = new Cookie("user", "admin"); cookie.setMaxAge(60*60*24*7);//有效期七天内有效 response.addCookie(cookie); response.getWriter().println("login success");&#125;//使用cookie的函数protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Cookie[] cookies = request.getCookies(); if( cookies==null ) &#123; response.getWriter().println("user not login"); &#125; String user = null; for( Cookie cookie : cookies ) &#123; System.out.println(cookie.getName() + ":" + cookie.getValue()); if( cookie.getName().equals("user") ) &#123; user = cookie.getValue(); break; &#125; &#125; if( user == null ) &#123; response.getWriter().println("user not login"); &#125;else &#123; response.getWriter().println("user : " + user); &#125;&#125; SessionSession(用户会话)： 用于保存于“浏览器窗口”对应的数据。它与Cookie的不同是：Cookie保存的数据在客户端，二Session保存的数据在服务器。 session是与窗口绑定的，保存在tomcat服务器的数据是30分钟. Session通过浏览器Cookie的SessionId提取对应用户的数据 浏览器第一次向服务器发送请求时，服务器在内存中开辟一块儿空间用于存放这个会话的信息，并把这块空间的id（sessionId）返回给浏览器。浏览器将sessionId存放在cookie中，之后每次向服务器发起请求都会携带这个cookie，告知服务器当前的会话。 JavaWeb三大作用域对象 HttpServletRequest – 请求响应完毕就消失了。 HttpSession – 第一次请求被创建，默认30分钟没有被访问就被销毁。此时把浏览器关掉其实是将存储在cookie中的sessionid抛弃，并没有被销毁。 ServletContext web – 应用启动时被创建，重启或关闭时被销毁。 程序开发时，为了便于维护，能用小作用域对象就用小作用域对象。 JSP九大内置对象 更新中，未完待续…]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 951 翻转二叉树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FLeetCode-951-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。 只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。 编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。 示例： 输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]输出：true解释：We flipped at nodes with values 1, 3, and 5. 提示：每棵树最多有 100 个节点。每棵树中的每个值都是唯一的、在 [0, 99] 范围内的整数。 题解先说一句，我没写出来。看到这个题我首先想的是怎么实现将某些节点交换左右子节点，而某些不换，从而判断两棵树是否相等。于是写了交换子节点的函数和判断两棵树是否相等的函数。且不说可行性，光O(n)就够我喝一壶的。然后我看了下网上大佬的题解才懂。我的代码理解都写在注释里。。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean flipEquiv(TreeNode root1, TreeNode root2) &#123; //若有一个或两个为空，返回两节点是否相等。具体结果是：若均为空，返回true；若一个为空，返回false if(root1 == null || root2 == null)&#123; return root1 == root2; &#125; //若两节点的值都不相等，那么自然树也不相等 if(root1.val != root2.val)&#123; return false; &#125; /* 分别比较root1和root2的：左左、右右、左右、右左。 若是可以通过交换子节点来使两根节点下的树相等， 那么将这两个根节点的四个子节点顺序进行排列组合， 若有一种情况下是两边相等,那么就可以通过交换而得；否则就不可以。 */ return flipEquiv(root1.left, root2.left) &amp;&amp; flipEquiv(root1.right, root2.right) || flipEquiv(root1.left, root2.right) &amp;&amp; flipEquiv(root1.right, root2.left); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 0102-二叉树的层次遍历]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2FLeetCode-0102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。例如:给定二叉树: [3,9,20,null,null,15,7],​ 返回其层次遍历结果：[ [3], [9,20], [15,7]] 题解我的思路是每行的节点都从左到右用一个队列或链表来存储，每次取队列头部并弹出。如果该节点有非空的后代节点则再加入队列，直到队列为空时停止。代码如下:12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res=new LinkedList&lt;&gt;(); LinkedList&lt;TreeNode&gt; queue=new LinkedList&lt;TreeNode&gt;(); if(root==null) return res; queue.offer(root); while(!queue.isEmpty())&#123; int size=queue.size(); List&lt;Integer&gt; subres=new LinkedList&lt;&gt;(); for(int i=0;i&lt;size;i++)&#123; TreeNode tmp=queue.pop(); subres.add(tmp.val); if(tmp.left!=null) queue.offer(tmp.left); if(tmp.right!=null) queue.offer(tmp.right); &#125; res.add(subres); &#125; return res; &#125;&#125; 耗时最少的是用递归法做的123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; //递归实现 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); if(root==null) return res; recursionLevelOrder(root,0,res); return res; &#125; private void recursionLevelOrder(TreeNode root,int level,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(root==null) return; if(res.size()==level)&#123; List&lt;Integer&gt; subres=new ArrayList&lt;&gt;(); subres.add(root.val); res.add(subres); &#125;else&#123; res.get(level).add(root.val); &#125; recursionLevelOrder(root.left,level+1,res); recursionLevelOrder(root.right,level+1,res); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型修饰符volatile]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2F%E7%B1%BB%E5%9E%8B%E4%BF%AE%E9%A5%B0%E7%AC%A6volatile%2F</url>
    <content type="text"><![CDATA[今天看Java并发时，看到了一个新的关键字volatile，觉得有必要记一下。 基础概念​ 先补充一下概念：Java 内存模型中的可见性、原子性和有序性。可见性： 可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。 在 Java 中 volatile、synchronized 和 final 实现可见性。 原子性： 原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。 在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。 有序性： ​ Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。 volatile原理 百度该字条，其内容是： volatile是一个类型修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。 ​ 如果查阅一下英文字典，有关volatile的解释，你会得到最常用的解释是“易变的，不稳定的”。这也是volatile关键字的含义。 ​ Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 ​ 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。 而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 ​ 当一个变量定义为 volatile 之后，将具备两种特性： 1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。 2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。 volatile 性能： volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML文档编写及XPath表达式使用]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FXML%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99%E5%8F%8AXPath%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[XML简介XML是可扩展标记语言(Extensible Markup Language，XML)缩写，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。可以用于Java程序配置描述文件、保存产生的数据、网络间数据传输等。 XML语法&amp;结构XML文档结构 第一行需是XML文档声明 有且只有一个根节点 书写规则与HTML相同 标签名使用小写英文, 单词间用-分隔多级标签之间不要存在重名 对特殊符号使用实体引用或CDATA标签5种实体引用12345&amp;lt; &lt;&amp;gt; &gt;&amp;amp; &amp;&amp;apos; '&amp;quot; " CDATA标签:&lt;![CDATA[不希望由XML解析的文本数据]]&gt; XML语义约束语义约束的两种定义方式:DTD与XML SchemaDTD利用DTD中的&lt;！ELEMENT&gt;标签定义XML文档中允许出现的节点及数量例: &lt;!ELEMENT hr (employee)&gt;&lt;!ELMENT name(#PCDATA)&gt; 定义name标签体只能是文本使用描述符表达子节点数量+ 至少出现1个子节点* 可出现0…n个子节点?最多出现1个子节点在XML中使用&lt;!DOCTYPE&gt;标签来引用DTD文件。书写格式:&lt;!DOCTYPE 根节点 SYSTEM &quot;dtd文件路径&quot;&gt; Schema比DTD更复杂XML Schema提供了数据类型、格式限定、数据范围等特性&lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;声明文本是Schema&lt;element&gt;代表标签节点&lt;complexType&gt;复杂节点, 标签包含子节点时使用&lt;sequence&gt;子标签按顺序排列&lt;attribute&gt;设置属性标签属性:name= 属性名称type= 属性值类型use=”required” 属性必须存在minOccurs=”n” 最小出现次数maxOccurs=”n” 最大出现次数&lt;simpleType&gt;简单类型。 代替属性:type使用&lt;restriction&gt;限定数据类型base=”xx” 基本类型&lt;minInclusive value=&quot;&quot;&gt;最小数据范围&lt;maxInclusive value=&quot;&quot;&gt;最大数据范围在XML文本的根节点添加1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;Schema文件路径&quot; 属性来关联schema文本 Dom4jDom4j是java用来读取和操作xml文档的一种方式。DOM(Document Object Model) 文档对象模型把xml文档看做一个树结构Dom4j的含义和作用 将xml文件视为Document对象 将xml文件中的标签视为Element对象使用时需下载dom4j的jar包并导入。 XPath基本表达式nodename: 选取此节点的所有子节点/ 从根节点选取// 从匹配选择的当前节点选择文档中的节点. 当前节点.. 当前节点的父节点@ 选取属性谓语表达式[1] 第一个匹配的元素[last()] 最后一个匹配的元素[last()-1] 倒数第二个匹配的元素[position()&lt;3] 最前面两个匹配的元素[@lang] 选取所有拥有lang属性的元素[@lang=&#39;value&#39;] 选取所有包含lang属性且属性值为value的元素[price&gt;35.00] 选取price元素值大于35.00的元素 总结下面是我写的一个例子：XML文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- &lt;!DOCTYPE hr SYSTEM "NewFile.dtd"&gt; --&gt;&lt;!-- 人力资源管理系统 --&gt;&lt;hr xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="hr.xsd"&gt; //xml schema文件名为hr.xsd &lt;employee no="3309"&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;31&lt;/age&gt; &lt;salary&gt;4000&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;会计部&lt;/dname&gt; &lt;address&gt;b103&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt; &lt;employee no="3310"&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;salary&gt;4000&lt;/salary&gt; &lt;department&gt; &lt;dname&gt;会计部&lt;/dname&gt; &lt;address&gt;b103&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt; &lt;employee no="3311"&gt; &lt;name&gt;张无忌&lt;/name&gt; &lt;age&gt;30&lt;/age&gt; &lt;salary&gt;3600&lt;/salary&gt; &lt;department&gt; &lt;department /&gt; &lt;dname&gt;人事部&lt;/dname&gt; &lt;address&gt;XX大厦-B105&lt;/address&gt; &lt;/department&gt; &lt;/employee&gt;&lt;/hr&gt; xml语义约束–xml schema文件(.xsd)12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.org/hr" xmlns:tns="http://www.example.org/hr" elementFormDefault="qualified"&gt; &lt;element name="hr"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name="employee" minOccurs="1" maxOccurs="9999"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name="name" type="string"&gt;&lt;/element&gt; &lt;element name="age"&gt; &lt;simpleType&gt; &lt;restriction base="integer"&gt; &lt;minInclusive value="18"&gt;&lt;/minInclusive&gt; &lt;maxInclusive value="60"&gt;&lt;/maxInclusive&gt; &lt;/restriction&gt; &lt;/simpleType&gt; &lt;/element&gt; &lt;element name="salary" type="integer"&gt;&lt;/element&gt; &lt;element name="department"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name="dname" type="string"&gt;&lt;/element&gt; &lt;element name="address" type="string"&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;attribute name="no" type="string" use="required"&gt;&lt;/attribute&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt; 读xml1234567891011121314151617181920212223242526272829303132333435package hr;import java.util.List;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class Hrreader &#123; void readXml() &#123; String file = "d:/Eclipse/workplace/calculator/src/NewFile.xml"; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); //获取文档根节点，即hr标签 Element root = document.getRootElement(); List&lt;Element&gt; employees = root.elements("employee"); for( Element employee : employees ) &#123; Element name = employee.element("name"); String empName = name.getText(); System.out.println(empName); System.out.println(employee.elementText("age")); System.out.println(employee.elementText("salary")); &#125; &#125; catch (DocumentException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Hrreader reader = new Hrreader(); reader.readXml(); &#125;&#125; 写xml12345678910111213141516171819202122232425262728293031323334353637383940414243package hr;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.Writer;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class HrWriter &#123; public void WriteXml()&#123; String file = "d:/Eclipse/workplace/calculator/src/NewFile.xml"; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); Element root = document.getRootElement(); Element employee = root.addElement("employee"); employee.addAttribute("no", "3311");// Element name = employee.addElement("name");// name.setText("李想"); employee.addElement("name").setText("张无忌"); employee.addElement("age").setText("30"); employee.addElement("salary").setText("3600"); Element department = employee.addElement("department"); department.addElement("department"); department.addElement("dname").setText("人事部"); department.addElement("address").setText("XX大厦-B105"); Writer writer = new OutputStreamWriter(new FileOutputStream(file), "UTF-8"); document.write(writer); writer.close(); &#125; catch (Exception e) &#123; // TODO: handl exception e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; HrWriter hrWriter = new HrWriter(); hrWriter.WriteXml(); &#125;&#125; 利用xpath进行xml文件的各种查找，类似数据库的查找语句12345678910111213141516171819202122232425262728293031323334353637383940package hr;import java.util.List;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.Node;import org.dom4j.io.SAXReader;public class XPathTestor &#123; public void xpath(String xpathExp) &#123; String file = "d:/Eclipse/workplace/calculator/src/NewFile.xml"; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); List&lt;Node&gt; nodes = document.selectNodes(xpathExp); for( Node node : nodes ) &#123; Element emp = (Element)node; System.out.println(emp.attributeValue("no")); System.out.println(emp.elementText("name")); System.out.println(emp.elementText("age")); System.out.println(emp.elementText("salary")); System.out.println("==========================="); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; XPathTestor testor = new XPathTestor(); // 查询 斜杠/代表根节点// testor.xpath("/hr/employee");// testor.xpath("//employee[@no=3311]");// testor.xpath("//employee[1]");// testor.xpath("//employee[last()]"); testor.xpath("//employee[position()&lt;3]");// testor.xpath("//employee[1] | //employee[2]"); &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 002-两数相加]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%95%B0%E8%AE%BA%2FLeetCode%20002%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[一道很简单的题，但是因为空指针的判别耗了很长时间… 题目 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 代码我的代码(虽然过了但是耗时多)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode now = new ListNode(0); ListNode res = now; while( l1!=null || l2!=null )&#123; boolean flag=false; int sum = 0; if(l1==null)&#123; sum += 0; &#125; else&#123; sum += l1.val; if( l1.next==null ) l1=null; else &#123; l1=l1.next; flag=true; &#125; &#125; if(l2==null)&#123; sum += 0; &#125; else &#123; sum += l2.val; if( l2.next==null) l2=null; else &#123; l2=l2.next; flag=true; &#125; &#125; now.val += sum; if( now.val&lt;10 )&#123; if( flag ) now.next = new ListNode(0); &#125; else&#123; now.next = new ListNode(now.val/10); now.val %= 10; &#125; now = now.next; &#125; return res; &#125;&#125; 官方题解12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 我没想到一个carry用两次，可以放在下一个循环继续用。]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS小记]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FCSS%2FCSS%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[以下是CSS的一些知识及语法。 什么是CSScss指层叠样式表（Cascading Style Sheets)样式通常存储在样式表中css可以统一不同浏览器显示的内容样式 CSS使用目的定义如何显示html元素解决内容（html元素）与表现（浏览器中的呈现）分离的问题 CSS基础语法 CSS声明： 样式属性：background-color 操作符: : 样式值：#FFFFFF 分隔符： ； 声明块：同时使用多个声明语句 1234&#123; background-color:#FFFFFF;color:#000000;&#125; CSS规则：1.选择器：定位页面中的元素2.声明块：由多个CSS声明组成，最外层{}，可以使用多个声明内容 定义CSS的两种方式：内联样式方式、外联样式方式 内联样式方式：&lt;p style=&quot;color:lightcoral;font-weight:bolder;&quot; &gt;&lt;/p&gt;内联方式设置样式只对当前标签有效 外联样式方式：在style内通过元素选择器 设置元素的声明块。此时相当于将CSS嵌入到HTML文件中。123456789101112131415161718&lt;!DOCSTYLE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta lang="en"/&gt;&lt;title&gt;定义CSS的样式&lt;/title&gt;&lt;style&gt;p&#123;color:lightcoral;font-weight:bolder;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p style="font-weight:bolder;color:red;"&gt; 这是内联样式1.&lt;/p&gt;&lt;p style="size:small;color:yellow;"&gt; 这是内联样式2.&lt;/p&gt;&lt;p&gt;这是外联样式&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 注：若进行了内联样式，则其优先级更高。即外联样式声明了元素样式后，若该元素同时进行了内联样式声明，则依照内联样式显示。 CSS选择器： ID选择器（ # +id值） 元素选择器（直接使用元素名称） 类（class）选择器（ . + class名称） 属性选择器（中括号里面写属性名称，如[title]） 后代元素选择器A E : 指定需要修改的元素E与A为祖先和后代关系A&gt;E : 指定需要修改的元素E与A为父元素和子元素关系B+E : 指定需要修改的元素E为B的下一个兄弟元素伪类：主要用于&lt;a&gt;标签。a:link – 链接的样式a:hover – 鼠标悬停时的样式a:active – 点击时的样式a:visited – 访问过后的样式伪元素::before – 为当前元素创建一个排在第一位的子元素。例q::before{ content:”&lt;”;}，会把页面中的引用标签&lt;q&gt;创建伪元素，把默认加的双引号变为&lt;;::after – 为当前元素创建一个排在最后一位的子元素。例q::after {content:”&gt;”;}，会把页面中的引用标签&lt;q&gt;创建伪元素，把默认加的双引号变为&gt;.CSS选择器优先级别1、内联&gt;外联2、内联：id&gt;类选择器&gt;元素/伪类3、在属性后加上：空格+!important让该属性升级为最高级别(会打乱默认的次序，少用) 背景属性background:简写属性，作用是将背景属性设置在一个声明中background-color：设置元素的背景颜色background-image:把图像设置为背景（通过url定位文件中的图片路径，将图片设置为背景）background-position：设置背景图像的起始位置background-repeat:设置背景图像是否及如何重复因为p元素作为一个块级元素出现，它默认占到页面的整个宽度，即使文本内容很少，但它依旧会占到页面的整个宽度，所以背景图片会重复显示以填充所有区域内容background-repeat:设置背景图像是否及如何重复repeat:表示水平和垂直方向都是重复显示的no-repeat:表示水平和垂直方向都是不重复显示的 Tips： 无文本信息仅插入图片时，无法正常显示图片。这是由于未显示文本，导致分配的大小为：0，无法正常显示。此时需要手动设置 高height和宽width； 需要显示部分图片时，可以通过更改 高height和宽width来调节显示图片的大小。高和宽的数值正负代表图片的移动方向，即：需要显示图片中某一块时，高和宽都是负值。 CSS文本样式color：设置字体颜色text-align：文本水平对齐text-decoration：向文本添加修饰text-indent：文本首行缩进vertical-align：文本垂直对齐 关于文本水平、垂直居中： 字体font-family 指定文本的字体系列font-size 指定文本的字体大小font-style 指定文本的字体样式font-weight 指定字体的粗细 列表与表格列表list-style 用于把所有用于列表的属性设置于一个声明中list-style-image 把图像设置为列表项标志list-style -type 设置列表项标志的类型 表格border 设置表格边框border-collapse 设置边框是否被折叠成单个或隔开width 定义表格的宽度text-align 表格中文本对齐padding 设置表格的填充(内边距) CSS盒子模型 内边距paddingpadding： 使用缩写属性设置在一个声明中的所有填充属性padding-bottom: 设置元素的底部填充padding-left： 设置元素的左部填充padding-right： 设置元素的右部填充padding-top: 设置元素的顶部填充注：padding：全部padding:上下 左右padding：上 左右 下padding：上 右 下 左 外边距margin类似。 边框 border:10px black solid;三个属性意思是：边框宽度 颜色 实/虚线 Tips：1.内外边距和边框的使用会使当前盒子变大2.内边距享有当前盒子背景色 CSS定位机制普通流(标准流):默认状态,从左往右, 从上到下排列块元素： 独占一行 可以设置宽、高 如果不设置宽度，宽度默认为容器的100% div、p、h1-h6、ul、ol、li、dl、dt、dd(定义列表) 行内元素 与其他元素同行显示 不可以设置宽、高 宽高就是文字或图片的宽高 span、a、b、i、u、em…… 浮动 只能使元素向左或向右移动, 不能上下移动 浮动元素碰到包含框 或另一个浮动框, 浮动停止 浮动元素之后的元素将围绕它, 之前的不受影响 浮动会脱离标准流浮动的基础语法float:leftfloat:rightfloat:nonefloat:inherit 继承父类的浮动效果 浮动的理解浮动可以实现块级元素在一行中横向排列。浮动的原理是：当前的块从当前的容器里面脱离出来，虽然浮动后脱离了文档流（容器）但是文本流还在，还是会占据文本空间（这里带来的问题是：原来下一个块的内容可能会被浮动的内容占满 使该块本身的内容溢出）清除浮动是把浮动元素回归文档流, 撑起重启高度。 清除浮动语法clear:none | left | right |both;none: 不清除浮动left: 清除该元素左边的浮动right: 清除该元素右边的浮动both: 清除所有浮动inherit: 继承父类清除浮动的值 清除浮动常用的方法 方法一：在浮动元素后使用一个空元素。例如：&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 方法二：给浮动元素的容器添加overflow：hidden;可同时添加 *zoom:1 /*触发hasLayout 兼容IE6、7*/ 方法三：使用CSS3的:after伪元素 12345678.clearfix:after&#123;content: ".";display: block;height: 0;visibility: hidden;clear: both;&#125;.clearfix&#123;*zoom:1; /*触发hasLayout 兼容IE6、7*/&#125; 方法四：通过父级元素清除浮动 (较少使用) 父级元素定义height。只适用于高度固定的布局。 父级元素也一起浮动。不推荐, 会产生新的浮动问题。 CSS定位position:既是一个定位布局模块（提供与元素定位和层叠相关功能，是一个核心模块，又是一个属性模块内包含： 盒子模型的类型和尺寸 布局模型 元素之间的关系 视口大小、图像大小等其他相关方面 重要的定位模型：static ：静态模型/自然模型relative：相对定位模型absolute：绝对定位模型fixed：固定定位模型sticky：磁铁定位模型 static：作用：使元素定位于 常规/自然流 中特点： 忽略 top/bottom/left/right 或者z-inherit声明 两个相邻的元素如果都设置外边距，最终外边距=两者外边距中最大的那个 具有固定width和height值的元素，若把左右外边距设置为auto，则左右外边距会自动扩大占满剩余宽度。造成水平居中效果。 relative：作用: 使元素成为可定位的祖先元素特点： 可以使用top/right/bottom/left/z-index相对于该元素的原位置进行偏移 相对定位的元素，原来在标准流中的位置依旧保留，后面元素接在元素原位置之后 任何元素都可设置relative, 它绝对定位的后代都可以相对它进行绝对定位 可以使的浮动元素发生偏移，并控制它们的堆叠顺序 absolute：作用：使元素脱离常规流特点： 脱离常规流 设置尺寸要注意：百分比比的是最近定位祖先元素 若没有最近定位祖先元素，会以&lt;body&gt;为祖先元素 left/right/top/bottom若设置为0，它将对齐到最近定位祖先元素的各边，居中效果。 若left/right/top/bottom设置为auto，它将会回归到常规流 fixed ：作用: 同absolute相同，使元素脱离常规流特点： fixed相对于视口(用户当前可见界面)做绝对定位 固定定位元素不会随着视口滚动而滚动 继承absolute特点 （left/right/top/bottom若设置为0，它将对齐到最近定位祖先元素的各边，居中效果。 若left/right/top/bottom设置为auto，它将会回归到常规流） sticky磁铁定位/粘性定位/吸附定位作用：relavtive+fixed的完美结合，制造出吸附效果特点： 如果产生偏移原位置还是会在常规流中，一亩三分地留着。 如果它的最近祖元素有滚动，那么它的偏移标尺就是最近祖先元素 如果最近祖先元素没有滚动 那么它的偏移标尺是视口。 上下左右的偏移规则 总结盒子模型: 通过改变元素的margin和padding来控制元素的移动。定位: 通过元素的位置移动改变出现在网页的相对位置。先通过定位调整元素的大体位置, 再用盒子模型调整元素最后的位置]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML小记]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FHTML%2FHTML%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[由于要学习Java Web开发，先学习一下HTML。下面是一些基础知识。 标题标签标题标签共有六级：&lt;h1,2,3,4,5,6&gt;&lt;/……&gt;如：1&lt;h1&gt;一级标题&lt;/h1&gt; 对应大小：h1,2,3,4,5,6–32px,24px,18px,16px,14px,12px1em=16px 段落1&lt;p&gt;段落内容&lt;/p&gt; 默认浏览器样式，空标签也会占位置（本来是空的，但由于浏览器可能默认设置为固定大小，因此需要自定义）； 标签的默认浏览器可能造成部分问题，建议自定义； 设置段落标签的属性:在head内的style中设置123456&lt;style&gt;p&#123; margin: 0; padding: 0;&#125;&lt;/style&gt; 如此，内外边距为0。 字体基本不用，一般在css中设置。1&lt;font&gt;字体内容&lt;/font&gt; size: 字体大小face：字体集color：颜色，三种表示法——名称，16进制，rgb坐标 链接123&lt;a&gt;HTML链接&lt;/a&gt;&lt;a href="http://www.makersy.top" target="_blank"&gt;博客&lt;/a&gt; (新建一个窗口)&lt;a href="http://www.makersy.top" target="_self"&gt;博客&lt;/a&gt; （在当前页面打开） 页面锚点123&lt;a href="#xxx"&gt;页面内锚点&lt;/a&gt;（跳转到id为xxx的地方）&lt;h3 id="xxx"&gt; 你好&lt;/h3&gt; 禁止跳转1&lt;a href="javascript:; / javascript:void(0);"&gt;死链接&lt;/a&gt; ---这是一个死链接 去掉下划线、去掉指向链接时光标的手形1234a&#123;text-decoration: none;cursor: none;&#125; 列表 无序列表 1&lt;ul&gt;&lt;li&gt;内容&lt;/li&gt;&lt;/ul&gt; 有序列表 1&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 定义列表 1234&lt;dl&gt; &lt;dt&gt;定义概念的名字&lt;/dt&gt; &lt;dd&gt;概念的解释 主体&lt;/dd&gt;&lt;/dl&gt; 贴士： type属性项目符号样式&lt;ul type=&quot;&quot;&gt;&lt;/ul&gt;（disc（实心圆）,circle（空心圆）,square(实心方形)，none表示不去设置它的项目符号样式，但会保留项目符号所在的位置）不建议使用！有序标签ol无法设置项目符号，独具特色的顺序就是他的项目符号定义列表也无法设置其项目符号 只用&lt;ul&gt;&lt;/ul&gt;无序列表就好了以后看到样式，都不要通过html（或者元素本身属性）去设置，通过css。 图像 标签 作用 插入图像 属性 src（src这个属性是图片的地址，有这个属性才能实现图像效果。） 支持格式： PNG、JPEG、GIF、PDF（引入的PDF必须是单页的） 非标签方式：background alt：在图片无法显示比如地址写错时，提示用户这里本来放的是什么 class:标识，用来指定标签的类名例：12345678910&lt;img alt="logo" src="https://img1.mukewang.com/5b8cef4200019d9a02000200-140-140.jpg"&gt;&lt;!-- 非标签方式 --&gt;&lt;style&gt;.logo&#123;background: url(https://img1.mukewang.com/5b8cef4200019d9a02000200-140-140.jpg);width: 140px;height: 150px;&#125;&lt;/style&gt;&lt;p class="logo"&gt;&lt;/p&gt; 插入本地图像路径：绝对路径– C:\html\logo.jpg，相对路径– 与文件同级目录下– ./img/logo.png 或者 ../logo.png div&lt;div&gt;&lt;/div&gt; 万能标签 无语义标签作用：布局贴士：非常常用且重要 现代布局常用 块级元素与行内元素块级元素垂直分段排列。行内元素水平一行内一个挨着一个。&lt;span&gt;包裹一行内容&lt;/span&gt;块级元素大小取决于开发者的设置，行内元素大小取决于内容 注释单行注释：&lt;!--注释文本--&gt;多行注释：&lt;!--注释开始--&gt;...&lt;!--注释结束--&gt;，这里，多行注释不会隐藏注释间的内容，只是开发时的提示。条件注释：&lt;!--[if IE 6]&gt;注释内容&lt;![endif]--&gt;，这里，条件注释主要用于浏览器兼容性。条件注释只在IE10以下版本的浏览器中生效。提示浏览器较旧。 一些不常用的标签以下标签一般都不用！！！文本格式化标签（为避免浏览器差异，一般不用，多用css设置） 12345678&lt;b&gt;加粗&lt;/b&gt;&lt;strong&gt;加粗2&lt;/strong&gt;&lt;big&gt;大号字体&lt;/big&gt;&lt;em&gt;强调字体(斜体)&lt;/em&gt;&lt;i&gt;斜体/图标&lt;/i&gt;&lt;small&gt;小号字体&lt;/small&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;sup&gt;上标&lt;/sup&gt; 预格式文本标签：&lt;pre&gt;一般这里是预览的代码&lt;/pre&gt;引用标签：&lt;blockquote&gt;引用来的&lt;/blockquote&gt;删除线标签：&lt;del&gt;删除的内容&lt;/del&gt;下划线标签:&lt;ins&gt;下划线的内容&lt;/ins&gt; 表格12345678910111213141516&lt;!-- 无序列表 --&gt;野生动物&lt;ul type="circle"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;栗子&lt;/li&gt;&lt;/ul&gt;&lt;!-- 有序列表 --&gt;&lt;ol&gt; &lt;li&gt;煎饼果子&lt;/li&gt; &lt;li&gt;台湾饭团&lt;/li&gt;&lt;/ol&gt;&lt;!-- 定义列表 --&gt;&lt;dl&gt; &lt;dt&gt;正数&lt;/dt&gt; &lt;dd&gt;大于0的自然数&lt;/dd&gt;&lt;/dl&gt; 表单标签&lt;form&gt; &lt;/form&gt;作用：手机用户输入的内容（文本、文件）属性：（1）action：提交到的服务端地址（2）method：指定提交时用哪种HTTP方法：POST/GET（3）name:标识（4）autocomplete:浏览器是否可以填充（5）enctype:指定表单内容编码input:文本、密码、单选、多选、按钮、数字、日期、颜色、范围、邮件、URL、文件select:下拉列表textarea:文本域button:按钮inout(单尖括号标签)文本：&lt;input type=&quot;text&quot;maxlength=&quot;&quot;(最大输入框长度)value=&quot;&quot;/&gt;密码：&lt;input type=&quot;password&quot;value=&quot;&quot;/&gt;单选：&lt;input type=&quot;radio&quot; name=&quot;&quot;vaule=&quot;&quot;/&gt;做单选操作，name要相同多选:&lt;input type=&quot;checkbox&quot;name=&quot;&quot;value=&quot;checked&quot;/&gt;(checked)默认选中按钮：&lt;input type=&quot;button&quot;value=&quot;&quot;/&gt;数字:&lt;input type=&quot;number&quot;/&gt;日期：&lt;input type=&quot;date&quot;/&gt;颜色：&lt;input type=&quot;color&quot;/&gt;(由于兼容性问题不是很常用)范围:&lt;input type=&quot;range&quot;min=&quot;&quot; max=&quot;&quot;/&gt;邮件:&lt;input type=&quot;email&quot;/&gt;提交按钮:&lt;input type=&quot;submit&quot;value=&quot;提交&quot;/&gt;URL:&lt;input type=&quot;url&quot;/&gt;(和邮件一样自带格式校验)文件：&lt;input type=&quot;file&quot;mulitple=&quot;multiple&quot;(多个文件)&gt;select：下拉列表如果&lt;select&gt;标签中设置了multiple或size属性的话,那么select就是列表了，不是下拉菜单；不设置是下拉菜单，所以代码实现了一个列表。multiple多选，size显示可见选项数目。12345678910111213&lt;select name="" id=""&gt;&lt;option value="" selected(设置默认值)&gt; &lt;/option&gt;&lt;option value="" &gt; &lt;/option&gt;&lt;option value="" &gt; &lt;/option&gt;&lt;/select&gt;textarea：文本域&lt;style&gt;textarea&#123;resize:none;(使其没有可拖拽能力）&#125;&lt;textarea rows=""(决定有几行高) cols=""(决定有多宽）&gt; 。。。。。（默认值） &lt;/textarea&gt;button：按钮&lt;button type=""(可以指明三个值 1、button 普通按钮 2、submit 带提交行为 3、reset 重置） form="(此处应该是表单的name) "&gt;提交（设置名字）&lt;/button&gt; 总结]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫笔记]]></title>
    <url>%2Fpython%2F%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[python爬虫笔记 判断请求是否成功1assert response.status_code==200 字符串格式化的一种方式1"你&#123;&#125;好".format(1) 使用代理ip 准备一堆ip地址，组成ip池，随机选择一个ip来使用 如何随机选择代理ip {“ip”:ip,”times”:0} [{},{},{},{},{}],对这个ip的列表进行排序，按照使用次数进行排序 选择使用次数较少的10个ip，从中随机选择一个 检查ip的可用性 可以使用requests添加超时参数，判断ip地址的质量 在线代理ip质量检测网站 携带cookie请求 尽量不使用cookie 携带一堆cookie进行请求，把cookie组成cookie池 请求登陆之后的网站的思路 实例化session 先使用session发送请求，登陆对网站，把cookie保存在session中 再使用session请求登录之后才能访问的网站，sesssion能够自动携带登陆成功时保存在其中的cookie，进行请求 不发送post请求，使用cookie获取登陆后的页面 cookie过期时间很长的网站 在cookie过期之前能够拿到所有的数据，比较麻烦 配合其他程序一起使用，其他程序专门其获取cookie，当前程序专门请求页面 字典推导式，列表推导式12cookies = "uuid_tt_dd=10_18697420810-1541514998525-406120; dc_session_id=10_1541514998525.130001; c_adb=1; smidV2=2018110622540004c9a404e4b4418224a1bc1f0afbaf24004db7a451c1dc9c0; UN=makersy; TY_SESSION_ID=bcb2fab5-1594-432f-b08b-77ff1c25478c; SESSION=04780891-f506-4bae-9eb9-7bee9b0f01b6; UserName=makersy; UserInfo=TY72nyXcSQ4kxcpYdP3noqwQsV904wqUfUrjssi1EYiqf77of1nXIX31igaPjkMfWt%2FBg37Ty5yCAFxluyxuwvK%2BjTb8WKRG2o8PpCGW7eCE5ImRX5bUUNkAvcYMhTjY; UserNick=makersy; AU=7FA; BT=1541516799322; UserToken=TY72nyXcSQ4kxcpYdP3noqwQsV904wqUfUrjssi1EYiqf77of1nXIX31igaPjkMfWt%2FBg37Ty5yCAFxluyxuwvK%2BjTb8WKRG2o8PpCGW7eAvjKefqLie1zAAltRYdzP1Sk%2Bfm7yuJ%2FP%2Fbsd6wSQVGMnSmTWc8bbv2HgJOkqFDhc%3D; ARK_ID=JSc5d36a4d0c44c361b2667ed6147b5607c5d3; dc_tos=phs2bi"cookies = &#123;i.split("=")[0]:i.split("=")[1] for i in cookies.split("; ")&#125; 获取登陆后的页面的三种方式 实例化session，使用session发送post请求，在使用他获取登陆后的页面 headers中添加cookie键，值为cookie字符串 在请求方法中添加cookie参数，接受字典形式的cookie，字典形式的cookie中的键是cookie的name对应的值，值是cookie的value对应的值]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java连接高版本mysql数据库(8.0)的坑]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2Fjava%E8%BF%9E%E6%8E%A5%E9%AB%98%E7%89%88%E6%9C%ACmysql%E6%95%B0%E6%8D%AE%E5%BA%93-8-0-%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[今天在写java连接mysql数据库时，遇到了无法连接的问题。报错信息如下: Loading class ‘com.mysql.jdbc.Driver’. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. Sat Sep 22 16:28:36 GMT+08:00 2018 WARN: Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. java.sql.SQLException: The server time zone value ‘???ú±ê×??±??’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 这三段意思是说： 驱动不再是之前的com.mysql.jdbc.Driver而是’com.mysql.cj.jdbc.Driver’； mysql8.0不需要使用ssl连接，因此需要设置手动设置useSSL=false； mysql返回的时间与实际不一样，需要设置在jdbc连接的url后面加上serverTimezone=GMT(即时区)。 因此应该这么写：1234 Class.forName("com.mysql.cj.jdbc.Driver");// Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost/EXAMPLE?useSSL=false&amp;serverTimezone=GMT","root","password");// conn = DriverManager.getConnection("jdbc:mysql://localhost/EXAMPLE","root","password"); 注释里是之前的写法。]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String&StringBuffer]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2FString-StringBuffer%2F</url>
    <content type="text"><![CDATA[String介绍 String是Java中很常见的类，是一个final修饰的不可变的数组，用来存放字符的容器。不可变是什么意思呢，意思是被赋值后就不能被改变了，如果再进行修改的话实质上是创建一个新对象，并将引用指向新对象，原来的对象被当做垃圾回收掉了。这是效率很低的。 用法1.求字符串某一位置字符 1char charAt(int index)//返回字符串中指定位置的字符；注意字符串中第一个字符索引是0，最后一个是length()-1。 1String str = new String("asdfzxc"); 2获取角标 1Int indexOf(char c) 例如： 1String s=”Java”; Int a=s.indexOf(a); 3判断 字符串是否包含某个字符串 1boolean contains(str)//判断源字符串是否包含str字符串并返回boolean值 例如：String str=”My love Java”; Boolean b=str.contains(love); 结果：true 字符串是否有内容 1boolean isEmpty() 例如：booleanb=str.isEmpty(); 字符串是否以指定内容开始 1boolean startsWith(str) 例如：booleanb=str.startsWith(“My”); 字符串是否以指定内容结束 1boolean endsWith(str); 用法如上 判断内容是否相同 1boolean equals(str) //String类重写了Object类中的equals方法，该方法用于判断字符串内容是否相同而非判断地址 例如: 12345String str1=”Java”;String str2=”love”;boolean s=str1.equals(str2); 判断内容是否相同，并忽略大小写 1Boolean equalsIngoreCase(str) 用法同上 4提取子串用String类的substring方法可以提取字符串中的子串，该方法有两种常用参数: public String substring(int beginIndex) //该方法从beginIndex位置起，从当前字符串中取出剩余的字符作为一个新的字符串返回。 public String substring(int beginIndex, int endIndex) //该方法从beginIndex位置起，从当前字符串中取出到endIndex-1位置的字符作为一个新的字符串返回 1231 String str1 = new String("asdfzxc");2 String str2 = str1.substring(2);//str2 = "dfzxc"3 String str3 = str1.substring(2,5);//str3 = "dfz" 5字符串比较 public int compareTo(StringanotherString) //该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。 public int compareToIgnore(StringanotherString) //与compareTo方法相似，但忽略大小写。 public boolean equals(ObjectanotherObject) //比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。 6字符串中字符的大小写转换 public String toLowerCase() //返回将当前字符串中所有字符转换成小写后的新串 public String toUpperCase() //返回将当前字符串中所有字符转换成大写后的新串 1231 String str = new String("asDF");2 String str1 = str.toLowerCase();//str1 = "asdf"3 String str2 = str.toUpperCase();//str2 = "ASDF" 7字符串中字符的替换 public String replace(char oldChar, charnewChar) //用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。 public String replaceFirst(String regex,String replacement) //该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。 public String replaceAll(String regex,String replacement) //该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。 1234567891 String str = "asdzxcasd";2 String str1 = str.replace('a','g');//str1 = "gsdzxcgsd"3 String str2 = str.replace("asd","fgh");//str2 = "fghzxcfgh"4 String str3 = str.replaceFirst("asd","fgh");//str3 = "fghzxcasd"5 String str4 = str.replaceAll("asd","fgh");//str4 = "fghzxcfgh"字符串分隔String[] split(String str)//将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。1 String str = "asd!qwe|zxc#";2 String[] str1 = str.split("!|#");//str1[0] = "asd";str1[1] = "qwe";str1[2] = "zxc"; 8字符串与基本类型的转换 字符串转换为基本类型java.lang包中有Byte、Short、Integer、Float、Double类的调用方法: public static byte parseByte(String s) public static short parseShort(String s) public static short parseInt(String s) public static long parseLong(String s) public static float parseFloat(String s) public static double parseDouble(String s) 字符串基本类型时，如int short dobule字符串中的数据一定要是数字，否则会出现异常。 例如： 1231 int n = Integer.parseInt("12");2 float f = Float.parseFloat("12.34");3 double d = Double.parseDouble("1.124"); 9基本类型转换为字符串类型 String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。 static String valueOf(char data[]) static String valueOf(char data[], intoffset, int count) static String valueOf(boolean b) static String valueOf(char c) static String valueOf(int i) static String valueOf(long l) static String valueOf(float f) static String valueOf(double d) 例如： 121 String s1 = String.valueOf(12);2 String s1 = String.valueOf(12.34); 10和数组有关的方法 返回类型 方法名 作用 byte[] getBytes() 将一个字符串转换成字节数组 String[] split(String) 将一个字符串按照指定内容劈开 char[] toCharArray() 将一个字符串转换成字符数组 11判断是否为空 public boolean isEmpty() 当且仅当 length()为 0 时返回 true。 String Buffer常用方法 public StringBuffer append(boolean b) 该方法的作用是追加内容到当前StringBuffer对象的末尾，类似于字符串的连接。调用该方法以后，StringBuffer对象的内容也发生改变， public StringBuffer deleteCharAt(int index) 该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。 public StringBuffer deleteCharAt(int index) 该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。 public StringBuffer insert(int offset, boolean b) 该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串。 public StringBuffer reverse() 该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串。 public void setCharAt(int index, char ch) 该方法的作用是修改对象中索引值为index位置的字符为新的字符ch。]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java大数基本用法]]></title>
    <url>%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2FJava%2FJava%E5%A4%A7%E6%95%B0%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近学Java有接触到大数运算，感觉比用c++自己写个算法方便太多，在此记录下代码。java中用于操作大数的类主要有两个，一个是BigInteger，代表大整数类，用于对大整数进行操作；另一个是BigDecimal，代表高精度类，用于对比较大或精度比较高的浮点型数据进行操作。两个比较像。 基本用法1、新建一个值为123的大整数对象12BigInteger a=new BigInteger(“123”); //第一种，参数是字符串 BigInteger a=BigInteger.valueOf(123); //第二种，参数可以是int、long 2、大整数的四则运算1234a. add(b); //a,b均为BigInteger类型，加法 a.subtract(b); //减 法 a.divide(b); //除法 a.multiply(b); //乘法 3、大整数比较大小12a.equals(b); //如果a、b相等返回true否则返回false a.compareTo(b); //a小于b返回-1，等于返回0，大于返回1 4、常用方法1234a.mod(b); //求余 a.gcd(b); //求最大公约数 a.max(b); //求最大值 a.min(b); //求最小值 例子HDU1002 a+b 12345678910111213141516171819import java.util.*;import java.math.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int t = sc.nextInt(); BigInteger a, b, c; for( int i=1; i&lt;=t; i++ ) &#123; System.out.println("Case " + i + ":"); a = sc.nextBigInteger(); b = sc.nextBigInteger(); System.out.println(a + " + " + b + " = " + a.add(b)); if( i!=t ) &#123; System.out.println(); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018CCPC-网络赛 1001 Buy and Resell]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E8%B4%AA%E5%BF%83%2F(HDU)2018CCPC-%E7%BD%91%E7%BB%9C%E8%B5%9B%201001%20Buy%20and%20Resell%2F</url>
    <content type="text"><![CDATA[Buy and Resell Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 2282 Accepted Submission(s): 359 Problem Description The Power Cube is used as a stash of Exotic Power. There are n cities numbered 1,2,…,n where allowed to trade it. The trading price of the Power Cube in the i-th city is ai dollars per cube. Noswal is a foxy businessman and wants to quietly make a fortune by buying and reselling Power Cubes. To avoid being discovered by the police, Noswal will go to the i-th city and choose exactly one of the following three options on the i-th day: spend ai dollars to buy a Power Cube resell a Power Cube and get ai dollars if he has at least one Power Cube do nothing Obviously, Noswal can own more than one Power Cubes at the same time. After going to the n cities, he will go back home and stay away from the cops. He wants to know the maximum profit he can earn. In the meanwhile, to lower the risks, he wants to minimize the times of trading (include buy and sell) to get the maximum profit. Noswal is a foxy and successful businessman so you can assume that he has infinity money at the beginning. Input There are multiple test cases. The first line of input contains a positive integer T (T≤250), indicating the number of test cases. For each test case:The first line has an integer n. (1≤n≤105)The second line has n integers a1,a2,…,an where ai means the trading price (buy or sell) of the Power Cube in the i-th city. (1≤ai≤109)It is guaranteed that the sum of all n is no more than 5×105. Output For each case, print one line with two integers —— the maximum profit and the minimum times of trading to get the maximum profit. Sample Input 341 2 10 959 5 9 10 522 1 Sample Output 16 45 20 0 题意有n个位置，每个位置有一个价格a[i]，按从1-n顺序经过每个位置，每个位置都可以进行三种操作之一且只能进行一次：1) 花a[i]元购买一个物品；2）卖掉一个手上的物品得到a[i]元； 3）什么也不做。假设金钱无限，初始没物品，身上可以装无限个物品，求走完所有城市后所能得到的最大利润和得到该最大利润所需的最少操作数。 题解低买高卖，此题可应用贪心的思想，每次遇到一个价格时，总是与前面的最低价进行“抵消”，这样利润最大。但是也许后面还有比这个价格更高的，所以需要“反悔”的机会，把错误时机卖出的损失挽回。因此优先队列（价格低标记值大先出队）代表已有物品，每到一个城市，先判断此地价格是不是比队列的最低价格高，是的话就可以将最低价格的物品卖掉了，再把差值加到利润上。然后最低价弹出，在队列里插入此地价格两个，分别以1和0标记（已经卖过一次，尚未卖过）。如此循环，假如后面有更高价想反悔，就把标记为1的错误卖出值弹出，队中标记为0的代表这个值现在是未被使用，可参与买卖。举个例子：样例中有“1 2 10 9”这个情况，首先花1元买物品，遇到2时我会把1给卖出，队里插入“2 1”“2 0”，利润为-1+2=1。后来又遇到10，2就属于贱卖当然不行，此时队里有两个2，让标记为1的出队，剩下的2的标记为0，代表没有被使用过，插入“10 1”“10 0”，此时利润值为1-2+10=9（跟1买10卖的利润是一样的）。下一个遇到9，此时队中最小为2，消之，利润计算为9-2+9=16。至于操作次数计算就简单了，只需要每次在标记为0的价格出队时总次数+2即可。以下为代码：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;struct node&#123; int v, s; //v--价格，s--状态 node(int a, int b):v(a), s(b)&#123;&#125; //重载&lt;运算符，使优先队列让v小的先出队，v相同则s大的先出队 //优先队列默认把结构体按从大到小排序，重载&lt;运算符使其按照自定义顺序排序 bool operator&lt;(const node &amp;a) const&#123; if( v==a.v ) return s&lt;a.s; return v&gt;a.v; &#125;&#125;;int main() &#123; int t; while( t-- )&#123; int n; LL profit=0, cnt=0; scanf("%d", &amp;n); priority_queue&lt;node&gt; que; for( int i=0; i&lt;n; i++ )&#123; int c; scanf("%d", &amp;c); if( !que.empty() &amp;&amp; que.top().v&lt;c )&#123; node tmp=que.top(); profit=profit-tmp.v+c; if( tmp.s==0 ) cnt+=2; //当前最小值之前没有买过，次数加2(以最小值买，以最大值卖) que.pop(); que.push(node(c, 1)); que.push(node(c, 0)); &#125; else&#123; que.push(node(c, 0)); &#125; &#125; printf("%lld %lld\n", profit, cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C/C++</tag>
        <tag>队列</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(HDU)2018CCPC - 网络赛 1004 Find Integer]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E6%95%B0%E8%AE%BA%2F(HDU)2018CCPC-%E7%BD%91%E7%BB%9C%E8%B5%9B%201004%20Find%20Integer%2F</url>
    <content type="text"><![CDATA[Find Integer Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Special Judge Problem Description people in USSS love math very much, and there is a famous math problem .give you two integers n,a,you are required to find 2 integers b,c such that an+bn=cn. Input one line contains one integer T;(1≤T≤1000000)next T lines contains two integers n,a;(0≤n≤1000,000,000,3≤a≤40000) Output print two integers b,c if b,c exits;(1≤b,c≤1000,000,000);else print two integers -1 -1 instead. Sample Input 1 2 3 Sample Output 4 5 题解本题给出一个费马大定理的表达式 —— $a^n+b^n=c^n,(a,b,c) \in Z$。 题目意思是给定该公式中的a和n，求满足公式的b和c并输出，若不存在满足公式的b和c，则输出”-1 -1”。所以当n&gt;2或n==0时输出”-1 -1”；当n=1时输出满足方程的第一组解：1 a+1；当n=2时输出勾股数。求勾股数：这种前n项固定的情况一般可以采用打表法。三层循环肯定是不行的，这么大数据量肯定tle。$a^2=c^2-b^2=(c+b)(c-b)$。令$x=c+b,y=c-b$，于是$a^2=xy$。从x着手，当满足a2可以整除x时就可以求出符合条件的b，c。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longstruct node&#123; ll b,c;&#125;gg[40007];void init()&#123; memset(gg, 0, sizeof(gg)); for( ll i=3; i&lt;=40000; i++ )&#123; for( ll j=1; j&lt;i; j++ )&#123; if( i*i%j==0 )&#123; //若a^2可以整除(c+b),则此式成立 ll x = j; ll y = i*i/j; if( (y-x)%2==0 )&#123; //若b为整数,则c也是整数 gg[i].c=(x+y)/2; gg[i].b=(y-x)/2; break; &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); int t; scanf("%d", &amp;t); while( t-- )&#123; ll a, n; scanf("%lld%lld", &amp;n, &amp;a); if( n&gt;2 || n==0 )&#123; printf("-1 -1\n"); continue; &#125; else if( n==1 )&#123; printf("1 %lld\n", a+1); continue; &#125; else&#123; if( gg[a].b )&#123; printf("%lld %lld\n", gg[a].b, gg[a].c); &#125; else printf("-1 -1\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C/C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT L2-019. 悄悄关注]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FSTL%2FPAT%20L2-019%20%E6%82%84%E6%82%84%E5%85%B3%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[一道水题 题目 新浪微博上有个“悄悄关注”，一个用户悄悄关注的人，不出现在这个用户的关注列表上，但系统会推送其悄悄关注的人发表的微博给该用户。现在我们来做一回网络侦探，根据某人的关注列表和其对其他用户的点赞情况，扒出有可能被其悄悄关注的人。 输入格式： 输入首先在第一行给出某用户的关注列表，格式如下： 人数N 用户1 用户2 …… 用户N 其中N是不超过5000的正整数，每个“用户i”（i=1, …, N）是被其关注的用户的ID，是长度为4位的由数字和英文字母组成的字符串，各项间以空格分隔。 之后给出该用户点赞的信息：首先给出一个不超过10000的正整数M，随后M行，每行给出一个被其点赞的用户ID和对该用户的点赞次数（不超过1000），以空格分隔。注意：用户ID是一个用户的唯一身份标识。题目保证在关注列表中没有重复用户，在点赞信息中也没有重复用户。 输出格式： 我们认为被该用户点赞次数大于其点赞平均数、且不在其关注列表上的人，很可能是其悄悄关注的人。根据这个假设，请你按用户ID字母序的升序输出可能是其悄悄关注的人，每行1个ID。如果其实并没有这样的人，则输出“Bing Mei You”。 输入样例1： 10 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao8Magi 50Pota 30LLao 3Ammy 48Dave 15GAO3 31Zoro 1Cath 60 输出样例1： AmmyCathPota 输入样例2： 11 GAO3 Magi Zha1 Sen1 Quan FaMK LSum Eins FatM LLao Pota7Magi 50Pota 30LLao 48Ammy 3Dave 15GAO3 31Zoro 29 输出样例2： Bing Mei You 题目比较简单，就是找出点赞数大于均值且名字不在关注列表里的人，排个序就好了。总结下： 用set存储元素时自动升序排序。set存储字符串用string； 存储数组一般开大些，’\0’会占位。如存储4个字母数组不能只开char[4]。 以下为代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;typedef struct &#123; char name[10]; int num;&#125;zan; //点赞信息zan a[10010];int main()&#123; set&lt;string&gt; men; //存储关注列表 set&lt;string&gt; se; //存储悄悄关注的人 set&lt;string&gt;::iterator it; int n; cin &gt;&gt;n; for( int i=0; i&lt;n; i++ )&#123; string s; cin &gt;&gt;s; men.insert(s); &#125; int m; double sum = 0; cin &gt;&gt;m; for( int i=0; i&lt;m; i++ )&#123; cin &gt;&gt;a[i].name &gt;&gt;a[i].num; sum += a[i].num; &#125; sum /= (m*1.0);//寻找符合条件的人 for( int i=0; i&lt;m; i++ )&#123; if( a[i].num &gt; sum )&#123; if( men.count(a[i].name) == 0 )&#123; se.insert(a[i].name); &#125; &#125; &#125; //结果列表空则输出没有，有则遍历输出 if( se.size() == 0 )&#123; printf("Bing Mei You\n"); &#125; else&#123; for( it=se.begin(); it!=se.end(); it++ )&#123; cout &lt;&lt;*it &lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2Funcategorized%2Fhello%2F</url>
    <content type="text"><![CDATA[Hello 嗯…花费了大概一天的时间才搭好这个基于Github+Hexo的博客，对于啥经验都没有的我来说，已经很满足了。参考了不少网上大佬的教程，遇到了很多百度也没有解答的问题(比如git bash不识别nodejs…)，但在完成后看到首页的瞬间还是很有成就感的。为什么要建博客呢，原因无外乎那几种，但最主要的还是想有个属于自己的地方，存放一些文章，记录学习、生活的历程，起个日记本的作用。 那么，就从今天开始吧。]]></content>
  </entry>
</search>
